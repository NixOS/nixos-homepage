<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">

<channel>
	<title>NixOS Planet</title>
	<link>http://planet.nixos.org</link>
	<language>en</language>
	<description>NixOS Planet - http://planet.nixos.org</description>
	<atom:link rel="self" href="http://planet.nixos.org/rss20.xml" type="application/rss+xml"/>

<item>
	<title>nixbuild.net: Introducing nixbuild.net</title>
	<guid isPermaLink="true">https://blog.nixbuild.net/posts/2020-02-18-introducing-nixbuild-net.html</guid>
	<link>https://blog.nixbuild.net/posts/2020-02-18-introducing-nixbuild-net.html</link>
	<description>&lt;p&gt;Exactly one month ago, I &lt;a href=&quot;https://discourse.nixos.org/t/announcing-nixbuild-net-nix-build-as-a-service&quot;&gt;announced&lt;/a&gt; the &lt;a href=&quot;https://nixbuild.net&quot;&gt;nixbuild.net&lt;/a&gt; service. Since then, there have been lots of work on functionality, performance and stability of the service. As of today, nixbuild.net is exiting alpha and entering private beta phase. If you want to try it out, just &lt;a href=&quot;mailto:rickard@nixbuild.net&quot;&gt;send me an email&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Today, I’m also launching the &lt;a href=&quot;https://blog.nixbuild.net&quot;&gt;nixbuild.net blog&lt;/a&gt;, which is intended as an outlet for anything related to the nixbuild.net service. Announcements, demos, technical articles and various tips and tricks. We’ll start out with a proper introduction of nixbuild.net; why it was built, what it can help you with and what the long-term goals are.&lt;/p&gt;

&lt;h2 id=&quot;why-nixbuild.net&quot;&gt;Why nixbuild.net?&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://nixos.org/nix/&quot;&gt;Nix&lt;/a&gt; has great built-in support for &lt;a href=&quot;https://nixos.org/nix/manual/#chap-distributed-builds&quot;&gt;distributing builds&lt;/a&gt; to remote machines. You just need to setup a standard Nix enviroment on your build machines, and make sure they are accessible via SSH. Just like that, you can offload your heavy builds to a couple of beefy build servers, saving your poor laptop’s fan from spinning up.&lt;/p&gt;
&lt;p&gt;However, just when you’ve tasted those sweet distributed builds you very likely run into the issue of &lt;em&gt;scaling&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;What if you need a really big server to run your builds, but only really need it once or twice per day? You’ll be wasting a lot of money keeping that build server available.&lt;/p&gt;
&lt;p&gt;And what if you occasionally have lots and lots of builds to run, or if your whole development team wants to share the build servers? Then you probably need to add more build servers, which means more wasted money when they are not used.&lt;/p&gt;
&lt;p&gt;So, you start looking into auto-scaling your build servers. This is quite easy to do if you use some cloud provider like AWS, Azure or GCP. But, this is where Nix will stop cooperating with you. It is really tricky to get Nix to work nicely together with an auto-scaled set of remote build machines. Nix has only a very coarse view of the “current load” of a build machine and can therefore not make very informed decisions on exactly how to distribute the builds. If there are multiple Nix instances (one for each developer in your team) fighting for the same resources, things get even trickier. It is really easy to end up in a situation where a bunch of really heavy builds are fighting for CPU time on the same build server while the other servers are idle or running lightweight build jobs.&lt;/p&gt;
&lt;p&gt;If you use &lt;a href=&quot;https://nixos.org/hydra/&quot;&gt;Hydra&lt;/a&gt;, the continous build system for Nix, you can find scripts for using auto-scaled AWS instances, but it is still tricky to set it up. And in the end, it doesn’t work perfectly since Nix/Hydra has no notion of “consumable” CPU/memory resources so the build scheduling is somewhat hit-and-miss.&lt;/p&gt;
&lt;p&gt;Even if you manage to come up with a solution that can handle your workload in an acceptable manner, you now have a new job: &lt;em&gt;maintaining&lt;/em&gt; uniquely configured build servers. Possibly for your whole company.&lt;/p&gt;
&lt;p&gt;Through my consulting company, &lt;a href=&quot;https://immutablesolutions.com/&quot;&gt;Immutable Solutions&lt;/a&gt;, I’ve done a lot of work on Nix-based deployments, and I’ve always struggled with half-baked solutions to the Nix build farm problem. This is how the idea of the nixbuild.net service was born — a service that can fill in the missing pieces of the Nix distributed build puzzle and package it as a simple, no-maintenance, cost-effective service.&lt;/p&gt;
&lt;h2 id=&quot;who-are-we&quot;&gt;Who are We?&lt;/h2&gt;
&lt;p&gt;nixbuild.net is developed and operated by me (Rickard Nilsson) and my colleague David Waern. We both have extensive experience in building Nix-based solutions, for ourselves and for various clients.&lt;/p&gt;
&lt;p&gt;We’re bootstrapping nixbuild.net, and we are long-term committed to keep developing and operating the service. Today, nixbuild.net can be productively used for its main purpose — running Nix builds in a scalable and cost-effective way — but there are lots of things that can (and will) be built on top of and around that core. Read more about this below.&lt;/p&gt;
&lt;h2 id=&quot;what-does-nixbuild.net-look-like&quot;&gt;What does nixbuild.net Look Like?&lt;/h2&gt;
&lt;p&gt;To the end-user, a person or team using Nix for building software, nixbuild.net behaves just like any other &lt;a href=&quot;https://nixos.org/nix/manual/#chap-distributed-builds&quot;&gt;remote build machine&lt;/a&gt;. As such, you can add it as an entry in your &lt;code&gt;/etc/nix/machines&lt;/code&gt; file:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;beta.nixbuild.net x86_64-linux - 100 1 big-parallel,benchmark&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;big-parallel,benchmark&lt;/code&gt; assignment is something that is called &lt;em&gt;system features&lt;/em&gt; in Nix. You can use that as a primitive scheduling strategy if you have multiple remote machines. Nix will only submit builds that have been marked as requiring a specific system feature to machines that are assigned that feature.&lt;/p&gt;
&lt;p&gt;The number 100 in the file above tells Nix that it is allowed to submit up to 100 simultaneous builds to &lt;code&gt;beta.nixbuild.net&lt;/code&gt;. Usually, you use this property to balance builds between remote machines, and to make sure that a machine doesn’t run too many builds at the same time. This works OK when you have rather homogeneous builds, and only one single Nix client is using a set of build servers. If multiple Nix clients use the same set of build servers, this simplistic scheduling breaks down, since a given Nix client loses track on how many builds are really running on a server.&lt;/p&gt;
&lt;p&gt;However, when you’re using nixbuild.net, you can set this number to anything really, since nixbuild.net will take care of the scheduling and scaling on its own, and it will not let multiple Nix clients step on each other’s toes. In fact each build that nixbuild.net runs is securely isolated from other builds and by default gets exclusive access to the resources (CPU and memory) it has been assigned.&lt;/p&gt;
&lt;p&gt;Apart from setting up the distributed Nix machines, you need to configure SSH. When you register an account on nixbuild.net, you’ll provide us with a public SSH key. The corresponding private key is used for connecting to nixbuild.net. This private key needs to be readable by the user that runs the Nix build. This is usually the &lt;code&gt;root&lt;/code&gt; user, if you have a standard Nix setup where the &lt;code&gt;nix-daemon&lt;/code&gt; process runs as the root user.&lt;/p&gt;
&lt;p&gt;That’s all there is to it, now we can run builds using nixbuild.net!&lt;/p&gt;
&lt;p&gt;Let’s try building the following silly build, just so we can see some action:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let pkgs = import &amp;lt;nixpkgs&amp;gt; { system = &quot;x86_64-linux&quot;; };

in pkgs.runCommand &quot;silly&quot; {} ''
  n=0
  while (($n &amp;lt; 12)); do
    date | tee -a $out
    sleep 10
    n=$(($n + 1))
  done
''&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This build will run for 2 minutes and output the current date every ten seconds:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ nix-build silly.nix
these derivations will be built:
  /nix/store/cy14fc13d3nzl65qp0sywvbjnnl48jf8-silly.drv
building '/nix/store/khvphdj3q7nyim46jk97fjp174damrik-silly.drv' on 'ssh://beta.nixbuild.net'...
Mon Feb 17 20:53:47 UTC 2020
Mon Feb 17 20:53:57 UTC 2020
Mon Feb 17 20:54:07 UTC 2020&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can see that Nix is telling us that the build is running on nixbuild.net!&lt;/p&gt;
&lt;h3 id=&quot;the-nixbuild.net-shell&quot;&gt;The nixbuild.net Shell&lt;/h3&gt;
&lt;p&gt;nixbuild.net supports a simple shell interface that you can access through SSH. This shell allows you to retrieve information about your builds on the service.&lt;/p&gt;
&lt;p&gt;For example, we can list the currently running builds:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ssh beta.nixbuild.net shell
nixbuild.net&amp;gt; list builds --running
10524 2020-02-17 21:05:20Z [40.95s] [Running]
      /nix/store/khvphdj3q7nyim46jk97fjp174damrik-silly.drv&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can also get information about any derivation or nix store path that has been built:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nixbuild.net&amp;gt; show drv /nix/store/khvphdj3q7nyim46jk97fjp174damrik-silly.drv
Derivation
  path = /nix/store/khvphdj3q7nyim46jk97fjp174damrik-silly.drv
  builds = 1
  successful builds = 1

Outputs
  out -&amp;gt; /nix/store/8c7sndr3npwmskj9zzp4347cnqh5p8q0-silly

Builds
  10524 2020-02-17 21:05:20Z [02:01] [Built]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This shell is under development, and new features are added continuously. A web-based frontend will also be implemented.&lt;/p&gt;
&lt;h2 id=&quot;the-road-ahead&quot;&gt;The Road Ahead&lt;/h2&gt;
&lt;p&gt;To finish up this short introduction to nixbuild.net, let’s talk a bit about our long-term goals for the service.&lt;/p&gt;
&lt;p&gt;The core purpose of nixbuild.net is to provide Nix users with pay-per-use distributed builds that are simple to set up and integrate into any workflow. The build execution should be performant and secure.&lt;/p&gt;
&lt;p&gt;There are a number of features that basically just are nice side-effects of the design of nixbuild.net:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Building a large number of variants of the same derivation (a build matrix or some sort of parameter sweep) will take the same time as running a single build, since nixbuild.net can run all builds in parallel.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Running repeated builds to find issues related to non-determinism/reproducability will not take longer than running a single build.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A whole team/company can share the same account in nixbuild.net letting builds be shared in a cost-effective way. If everyone in a team delegates builds to nixbuild.net, the same derivation will never have to be built twice. This is similar to having a shared Nix cache, but avoids having to configure a cache and perform network uploads for each build artifact. Of course, nixbuild.net can be combined with a Nix cache too, if desired.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Beyond the above we have lots of thoughts on where we want to take nixbuild.net. I’m not going to enumerate possible directions here and now, but one big area that nixbuild.net is particularly suited for is advanced build analysis and visualisation. The sandbox that has been developed to securely isolate builds from each other also gives us a unique way to analyze exactly how a build behaves. One can imagine nixbuild.net being able give very detailed feedback to users about build bottlenecks, performance regressions, unused dependencies etc.&lt;/p&gt;
&lt;p&gt;With that said, our primary focus right now is to make nixbuild.net a robust workhorse for your Nix builds, enabling you to fully embrace Nix without being limited by local compute resources. Please &lt;a href=&quot;mailto:rickard@nixbuild.net&quot;&gt;get in touch&lt;/a&gt; if you want try out nixbuild.net, or if you have any questions or comments!&lt;/p&gt;</description>
	<pubDate>Tue, 18 Feb 2020 00:00:00 +0000</pubDate>
	<author>support@nixbuild.net (nixbuild.net)</author>
</item>
<item>
	<title>Sander van der Burg: A declarative process manager-agnostic deployment framework based on Nix tooling</title>
	<guid isPermaLink="false">tag:blogger.com,1999:blog-1397115249631682228.post-3829850759126756827</guid>
	<link>http://sandervanderburg.blogspot.com/2020/02/a-declarative-process-manager-agnostic.html</link>
	<description>In a previous blog post written two months ago, &lt;a href=&quot;https://sandervanderburg.blogspot.com/2019/11/a-nix-based-functional-organization-for.html&quot;&gt;I have introduced a new experimental Nix-based process framework&lt;/a&gt;, that provides the following features:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;It uses the &lt;strong&gt;Nix expression language&lt;/strong&gt; for configuring running process instances, including their dependencies. The configuration process is based on only a few &lt;strong&gt;simple concepts&lt;/strong&gt;: function definitions to define constructors that generate process manager configurations, function invocations to compose running process instances, and &lt;a href=&quot;https://sandervanderburg.blogspot.com/2013/09/managing-user-environments-with-nix.html&quot;&gt;Nix profiles&lt;/a&gt; to make collections of process configurations accessible from a single location.&lt;/li&gt;&lt;li&gt;The &lt;strong&gt;Nix package manager&lt;/strong&gt; delivers all packages and configuration files and isolates them in the Nix store, so that they never conflict with other running processes and packages.&lt;/li&gt;&lt;li&gt;It identifies &lt;strong&gt;process dependencies&lt;/strong&gt;, so that a process manager can ensure that processes are activated and deactivated in the right order.&lt;/li&gt;&lt;li&gt;The ability to deploy &lt;strong&gt;multiple instances&lt;/strong&gt; of the same process, by making conflicting resources configurable.&lt;/li&gt;&lt;li&gt;Deploying processes/services as an &lt;strong&gt;unprivileged user&lt;/strong&gt;.&lt;/li&gt;&lt;li&gt;Advanced concepts and features, such as &lt;a href=&quot;http://man7.org/linux/man-pages/man7/namespaces.7.html&quot;&gt;namespaces&lt;/a&gt; and &lt;a href=&quot;http://man7.org/linux/man-pages/man7/cgroups.7.html&quot;&gt;cgroups&lt;/a&gt;, are &lt;strong&gt;not required&lt;/strong&gt;.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;Another objective of the framework is that it should work with a variety of process managers on a variety of operating systems.&lt;br /&gt;&lt;br /&gt;In my previous blog post, I was deliberately using sysvinit scripts (also known as LSB Init compliant scripts) to manage the lifecycle of running processes as a starting point, because they are universally supported on Linux and self contained -- sysvinit scripts only require the right packages installed, but they do not rely on external programs that manage the processes' life-cycle. Moreover, sysvinit scripts can also be conveniently used as an unprivileged user.&lt;br /&gt;&lt;br /&gt;I have also developed a Nix function that can be used to more conveniently generate sysvinit scripts. Traditionally, these scripts are written by hand and basically require that the implementer writes the same boilerplate code over and over again, such as the activities that start and stop the process.&lt;br /&gt;&lt;br /&gt;The sysvinit script generator function can also be used to directly specify the implementation of all activities that manage the life-cycle of a process, such as:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;{createSystemVInitScript, nginx, stateDir}:&lt;br /&gt;{configFile, dependencies ? [], instanceSuffix ? &quot;&quot;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  instanceName = &quot;nginx${instanceSuffix}&quot;;&lt;br /&gt;  nginxLogDir = &quot;${stateDir}/${instanceName}/logs&quot;;&lt;br /&gt;in&lt;br /&gt;createSystemVInitScript {&lt;br /&gt;  name = instanceName;&lt;br /&gt;  description = &quot;Nginx&quot;;&lt;br /&gt;  activities = {&lt;br /&gt;    start = ''&lt;br /&gt;      mkdir -p ${nginxLogDir}&lt;br /&gt;      log_info_msg &quot;Starting Nginx...&quot;&lt;br /&gt;      loadproc ${nginx}/bin/nginx -c ${configFile} -p ${stateDir}&lt;br /&gt;      evaluate_retval&lt;br /&gt;    '';&lt;br /&gt;    stop = ''&lt;br /&gt;      log_info_msg &quot;Stopping Nginx...&quot;&lt;br /&gt;      killproc ${nginx}/bin/nginx&lt;br /&gt;      evaluate_retval&lt;br /&gt;    '';&lt;br /&gt;    reload = ''&lt;br /&gt;      log_info_msg &quot;Reloading Nginx...&quot;&lt;br /&gt;      killproc ${nginx}/bin/nginx -HUP&lt;br /&gt;      evaluate_retval&lt;br /&gt;    '';&lt;br /&gt;    restart = ''&lt;br /&gt;      $0 stop&lt;br /&gt;      sleep 1&lt;br /&gt;      $0 start&lt;br /&gt;    '';&lt;br /&gt;    status = &quot;statusproc ${nginx}/bin/nginx&quot;;&lt;br /&gt;  };&lt;br /&gt;  runlevels = [ 3 4 5 ];&lt;br /&gt;&lt;br /&gt;  inherit dependencies instanceName;&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;In the above Nix expression, we specify five activities to manage the life-cycle of Nginx, a free/open source web server:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;The &lt;strong&gt;start&lt;/strong&gt; activity initializes the state of Nginx and starts the process (&lt;a href=&quot;https://sandervanderburg.blogspot.com/2020/01/writing-well-behaving-daemon-in-c.html&quot;&gt;as a daemon&lt;/a&gt; that runs in the background).&lt;/li&gt;&lt;li&gt;&lt;strong&gt;stop&lt;/strong&gt; stops the Nginx daemon.&lt;/li&gt;&lt;li&gt;&lt;strong&gt;reload&lt;/strong&gt; instructs Nginx to reload its configuration&lt;/li&gt;&lt;li&gt;&lt;strong&gt;restart&lt;/strong&gt; restarts the process&lt;/li&gt;&lt;li&gt;&lt;strong&gt;status&lt;/strong&gt; shows whether the process is running or not.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;Besides directly implementing activities, the Nix function invocation shown above can also be used on a much &lt;strong&gt;higher level&lt;/strong&gt; -- typically, sysvinit scripts follow the same conventions. Nearly all sysvinit scripts implement the activities described above to manage the life-cycle of a process, and these typically need to be re-implemented over and over again.&lt;br /&gt;&lt;br /&gt;We can also generate the implementations of these activities automatically from a high level specification, such as:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;{createSystemVInitScript, nginx,  stateDir}:&lt;br /&gt;{configFile, dependencies ? [], instanceSuffix ? &quot;&quot;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  instanceName = &quot;nginx${instanceSuffix}&quot;;&lt;br /&gt;  nginxLogDir = &quot;${stateDir}/${instanceName}/logs&quot;;&lt;br /&gt;in&lt;br /&gt;createSystemVInitScript {&lt;br /&gt;  name = instanceName;&lt;br /&gt;  description = &quot;Nginx&quot;;&lt;br /&gt;  initialize = ''&lt;br /&gt;    mkdir -p ${nginxLogDir}&lt;br /&gt;  '';&lt;br /&gt;  process = &quot;${nginx}/bin/nginx&quot;;&lt;br /&gt;  args = [ &quot;-c&quot; configFile &quot;-p&quot; stateDir ];&lt;br /&gt;  runlevels = [ 3 4 5 ];&lt;br /&gt;&lt;br /&gt;  inherit dependencies instanceName;&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;You could basically say that the above &lt;i&gt;createSystemVInitScript&lt;/i&gt; function invocation makes the configuration process of a sysvinit script &quot;&lt;a href=&quot;https://sandervanderburg.blogspot.com/2016/03/the-nixos-project-and-deploying-systems.html&quot;&gt;&lt;strong&gt;more declarative&lt;/strong&gt;&lt;/a&gt;&quot; -- you do not need to specify the activities that need to be executed to manage processes, but instead, you specify the &lt;strong&gt;relevant characteristics&lt;/strong&gt; of a running process.&lt;br /&gt;&lt;br /&gt;From this high level specification, the implementations for all required activities will be derived, using conventions that are commonly used to write sysvinit scripts.&lt;br /&gt;&lt;br /&gt;After completing the initial version of the process management framework that works with sysvinit scripts, I have also been investigating other process managers. I discovered that their configuration processes have many things in common with the sysvinit approach. As a result, I have decided to explore these declarative deployment concepts a bit further.&lt;br /&gt;&lt;br /&gt;In this blog post, I will describe a declarative process manager-agnostic deployment approach that we can integrate into the experimental Nix-based process management framework.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Writing declarative deployment specifications for managed running processes&lt;/h2&gt;&lt;br /&gt;As explained in the introduction, I have also been experimenting with other process managers than sysvinit. For example, instead of generating a sysvinit script that manages the life-cycle of a process, such as the Nginx server, we can also generate a supervisord configuration file to define Nginx as a program that can be managed with supervisord:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;{createSupervisordProgram, nginx, stateDir}:&lt;br /&gt;{configFile, dependencies ? [], instanceSuffix ? &quot;&quot;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  instanceName = &quot;nginx${instanceSuffix}&quot;;&lt;br /&gt;  nginxLogDir = &quot;${stateDir}/${instanceName}/logs&quot;;&lt;br /&gt;in&lt;br /&gt;createSupervisordProgram {&lt;br /&gt;  name = instanceName;&lt;br /&gt;  command = &quot;mkdir -p ${nginxLogDir}; &quot;+&lt;br /&gt;    &quot;${nginx}/bin/nginx -c ${configFile} -p ${stateDir}&quot;;&lt;br /&gt;  inherit dependencies;&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;Invoking the above function will generate a supervisord program configuration file, instead of a sysvinit script.&lt;br /&gt;&lt;br /&gt;With the following Nix expression, we can generate a systemd unit file so that Nginx's life-cycle can be managed by systemd:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;{createSystemdService, nginx, stateDir}:&lt;br /&gt;{configFile, dependencies ? [], instanceSuffix ? &quot;&quot;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  instanceName = &quot;nginx${instanceSuffix}&quot;;&lt;br /&gt;  nginxLogDir = &quot;${stateDir}/${instanceName}/logs&quot;;&lt;br /&gt;in&lt;br /&gt;createSystemdService {&lt;br /&gt;  name = instanceName;&lt;br /&gt;  Unit = {&lt;br /&gt;    Description = &quot;Nginx&quot;;&lt;br /&gt;  };&lt;br /&gt;  Service = {&lt;br /&gt;    ExecStartPre = &quot;+mkdir -p ${nginxLogDir}&quot;;&lt;br /&gt;    ExecStart = &quot;${nginx}/bin/nginx -c ${configFile} -p ${stateDir}&quot;;&lt;br /&gt;    Type = &quot;simple&quot;;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  inherit dependencies;&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;What you may probably notice when comparing the above two Nix expressions with the last sysvinit example (that captures process characteristics instead of activities), is that they all contain very similar properties. Their main difference is a slightly different organization and naming convention, because each abstraction function is tailored towards the configuration conventions that each target process manager uses.&lt;br /&gt;&lt;br /&gt;As discussed in my previous blog post about declarative programming and deployment, declarativity is a spectrum -- the above specifications are (somewhat) declarative because they do not capture the activities to manage the life-cycle of the process (the &lt;strong&gt;how&lt;/strong&gt;). Instead, they specify &lt;strong&gt;what&lt;/strong&gt; process we want to run. The process manager derives and executes all activities to bring that process in a running state.&lt;br /&gt;&lt;br /&gt;sysvinit scripts themselves are not declarative, because they specify all activities (i.e. shell commands) that need to be executed to accomplish that goal. supervisord configurations and systemd services configuration files are (somewhat) declarative, because they capture process characteristics -- the process manager executes derives all required activities to bring the process in a running state.&lt;br /&gt;&lt;br /&gt;Despite the fact that I am not specifying any process management activities, these Nix expressions could still be considered somewhat a &quot;how specification&quot;, because each configuration is tailored towards a specific process manager. A process manager, such as syvinit, is a means to accomplish something else: getting a running process whose life-cycle can be conveniently managed.&lt;br /&gt;&lt;br /&gt;If I would revise the above specifications to only express what I kind of running process I want, disregarding the process manager, then I could simply write:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;{createManagedProcess, nginx, stateDir}:&lt;br /&gt;{configFile, dependencies ? [], instanceSuffix ? &quot;&quot;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  instanceName = &quot;nginx${instanceSuffix}&quot;;&lt;br /&gt;  nginxLogDir = &quot;${stateDir}/${instanceName}/logs&quot;;&lt;br /&gt;in&lt;br /&gt;createManagedProcess {&lt;br /&gt;  name = instanceName;&lt;br /&gt;  description = &quot;Nginx&quot;;&lt;br /&gt;  initialize = ''&lt;br /&gt;    mkdir -p ${nginxLogDir}&lt;br /&gt;  '';&lt;br /&gt;  process = &quot;${nginx}/bin/nginx&quot;;&lt;br /&gt;  args = [ &quot;-c&quot; configFile&quot; -p&quot; &quot;${stateDir}/${instanceName}&quot; ];&lt;br /&gt;&lt;br /&gt;  inherit dependencies instanceName;&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above Nix expression simply states that we want to run a managed Nginx process (using certain command-line arguments) and before starting the process, we want to initialize the state by creating the log directory, if it does not exists yet.&lt;br /&gt;&lt;br /&gt;I can translate the above specification to all kinds of configuration artifacts that can be used by a variety of process managers to accomplish the same outcome. I have developed six kinds of generators allowing me to target the following process managers:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;sysvinit scripts, also known as &lt;a href=&quot;https://wiki.debian.org/LSBInitScripts&quot;&gt;LSB Init compliant scripts&lt;/a&gt;.&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://supervisord.org&quot;&gt;supervisord&lt;/a&gt; programs&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.freedesktop.org/wiki/Software/systemd&quot;&gt;systemd&lt;/a&gt; services&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.launchd.info&quot;&gt;launchd&lt;/a&gt; services&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.freebsd.org/doc/en_US.ISO8859-1/articles/rc-scripting/index.html&quot;&gt;BSD rc&lt;/a&gt; scripts&lt;/li&gt;&lt;li&gt;Windows services (via Cygwin's &lt;a href=&quot;http://web.mit.edu/cygwin/cygwin_v1.3.2/usr/doc/Cygwin/cygrunsrv.README&quot;&gt;cygrunsrv&lt;/a&gt;)&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;Translating the properties of the process manager-agnostic configuration to a process manager-specific properties is quite straight forward for most concepts -- in many cases, there is a direct mapping between a property in the process manager-agnostic configuration to a process manager-specific property.&lt;br /&gt;&lt;br /&gt;For example, when we intend to target supervisord, then we can translate the &lt;i&gt;process&lt;/i&gt; and &lt;i&gt;args&lt;/i&gt; parameters to a &lt;i&gt;command&lt;/i&gt; invocation. For systemd, we can translate &lt;i&gt;process&lt;/i&gt; and &lt;i&gt;args&lt;/i&gt; to the &lt;i&gt;ExecStart&lt;/i&gt; property that refers to a command-line instruction that starts the process.&lt;br /&gt;&lt;br /&gt;Although the process manager-agnostic abstraction function supports enough features to get some well known system services working (e.g. Nginx, Apache HTTP service, PostgreSQL, MySQL etc.), it does not facilitate all possible features of each process manager -- it will provide a reasonable set of common features to get a process running and to impose some restrictions on it.&lt;br /&gt;&lt;br /&gt;It is still possible work around the feature limitations of process manager-agnostic deployment specifications. We can also influence the generation process by defining &lt;strong&gt;overrides&lt;/strong&gt; to get process manager-specific properties supported:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;{createManagedProcess, nginx, stateDir}:&lt;br /&gt;{configFile, dependencies ? [], instanceSuffix ? &quot;&quot;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  instanceName = &quot;nginx${instanceSuffix}&quot;;&lt;br /&gt;  nginxLogDir = &quot;${stateDir}/${instanceName}/logs&quot;;&lt;br /&gt;in&lt;br /&gt;createManagedProcess {&lt;br /&gt;  name = instanceName;&lt;br /&gt;  description = &quot;Nginx&quot;;&lt;br /&gt;  initialize = ''&lt;br /&gt;    mkdir -p ${nginxLogDir}&lt;br /&gt;  '';&lt;br /&gt;  process = &quot;${nginx}/bin/nginx&quot;;&lt;br /&gt;  args = [ &quot;-c&quot; configFile&quot; -p&quot; &quot;${stateDir}/${instanceName}&quot; ];&lt;br /&gt;&lt;br /&gt;  inherit dependencies instanceName;&lt;br /&gt;&lt;br /&gt;  overrides = {&lt;br /&gt;    sysvinit = {&lt;br /&gt;      runlevels = [ 3 4 5 ];&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;In the above example, we have added an override specifically for sysvinit to tell that the init system that the process should be started in runlevels 3, 4 and 5 (which implies the process should stopped in the remaining runlevels: 0, 1, 2, and 6). The other process managers that I have worked with do not have a notion of runlevels.&lt;br /&gt;&lt;br /&gt;Similarly, we can use an override to, for example, use systemd-specific features to run a process in a Linux namespace etc.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Simulating process manager-agnostic concepts with no direct equivalents&lt;/h2&gt;&lt;br /&gt;For some process manager-agnostic concepts, process managers do not always have direct equivalents. In such cases, there is still the possibility to apply non-trivial simulation strategies.&lt;br /&gt;&lt;br /&gt;&lt;h3&gt;Foreground processes or daemons&lt;/h3&gt;&lt;br /&gt;What all deployment specifications shown in this blog post have in common is that their main objective is to bring a process in a running state. How these processes are expected to behave is different among process managers.&lt;br /&gt;&lt;br /&gt;sysvinit and BSD rc scripts expect processes to &lt;strong&gt;daemonize&lt;/strong&gt; -- on invocation, a process spawns another process that keeps running in the background (the daemon process). After the initialization of the daemon process is done, the parent process terminates. If processes do not deamonize, the startup process execution blocks indefinitely.&lt;br /&gt;&lt;br /&gt;Daemons introduce another complexity from a process management perspective -- when invoking an executable from a shell session in background mode, the shell can you tell its process ID, so that it can be stopped when it is no longer necessary.&lt;br /&gt;&lt;br /&gt;With deamons, an invoked processes forks another child process (or when it supposed to really behave well: it double forks) that becomes the daemon process. The daemon process gets adopted by the init system, and thus remains in the background even if the shell session ends.&lt;br /&gt;&lt;br /&gt;The shell that invokes the executable does not know the PIDs of the resulting daemon processes, because that value is only propagated to the daemon's parent process, not the calling shell session. To still be able to control it, a well-behaving daemon typically writes its process IDs to a so-called PID file, so that it can be reliably terminated by a shell command when it is no longer required.&lt;br /&gt;&lt;br /&gt;sysvinit and BSD rc scripts extensively use PID files to control daemons. By using a process' PID file, the managing sysvinit/BSD rc script can tell you whether a process is running or not and reliably terminate a process instance.&lt;br /&gt;&lt;br /&gt;&quot;More modern&quot; process managers, such as launchd, supervisord, and cygrunsrv, do not work with processes that daemonize -- instead, these process managers are daemons themselves that invoke processes that work in &quot;foreground mode&quot;.&lt;br /&gt;&lt;br /&gt;One of the advantages of this approach is that services can be more reliably controlled -- because their PIDs are directly propagated to the controlling daemon from the &lt;i&gt;fork()&lt;/i&gt; library call, it is no longer required to work with PID files, that may not always work reliably (for example: a process might abrubtly terminate and never clean its PID file, giving the system the false impression that it is still running).&lt;br /&gt;&lt;br /&gt;systemd improves process control even further by using Linux cgroups -- although foreground process may be controlled more reliably than daemons, they can still fork other processes (e.g. a web service that creates processes per connection). When the controlling parent process terminates, and does not properly terminate its own child processes, they may keep running in the background indefintely. With cgroups it is possible for the process manager to retain control over all processes spawned by a service and terminate them when a service is no longer needed.&lt;br /&gt;&lt;br /&gt;systemd has another unique advantage over the other process managers -- it can work both with foreground processes and daemons, although foreground processes seem to have to preference according to the documentation, because they are much easier to control and develop.&lt;br /&gt;&lt;br /&gt;Many common system services, such as OpenSSH, MySQL or Nginx, have the ability to both run as a foreground process and as a daemon, typically by providing a command-line parameter or defining a property in a configuration file.&lt;br /&gt;&lt;br /&gt;To provide an optimal user experience for all supported process managers, it is typically a good thing in the process manager-agnostic deployment specification to specify both how a process can be used as a foreground process and as a daemon:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;{createManagedProcess, nginx, stateDir, runtimeDir}:&lt;br /&gt;{configFile, dependencies ? [], instanceSuffix ? &quot;&quot;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  instanceName = &quot;nginx${instanceSuffix}&quot;;&lt;br /&gt;  nginxLogDir = &quot;${stateDir}/${instanceName}/logs&quot;;&lt;br /&gt;in&lt;br /&gt;createManagedProcess {&lt;br /&gt;  name = instanceName;&lt;br /&gt;  description = &quot;Nginx&quot;;&lt;br /&gt;  initialize = ''&lt;br /&gt;    mkdir -p ${nginxLogDir}&lt;br /&gt;  '';&lt;br /&gt;  process = &quot;${nginx}/bin/nginx&quot;;&lt;br /&gt;  args = [ &quot;-p&quot; &quot;${stateDir}/${instanceName}&quot; &quot;-c&quot; configFile ];&lt;br /&gt;  foregroundProcessExtraArgs = [ &quot;-g&quot; &quot;daemon off;&quot; ];&lt;br /&gt;  daemonExtraArgs = [ &quot;-g&quot; &quot;pid ${runtimeDir}/${instanceName}.pid;&quot; ];&lt;br /&gt;&lt;br /&gt;  inherit dependencies instanceName;&lt;br /&gt;&lt;br /&gt;  overrides = {&lt;br /&gt;    sysvinit = {&lt;br /&gt;      runlevels = [ 3 4 5 ];&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;In the above example, we have revised Nginx expression to both specify how the process can be started as a foreground process and as a daemon. The only thing that needs to be configured differently is one global directive in the Nginx configuration file -- by default, Nginx runs as a deamon, but by adding the &lt;i&gt;daemon off;&lt;/i&gt; directive to the configuration we can run it in foreground mode.&lt;br /&gt;&lt;br /&gt;When we run Nginx as daemon, we configure a PID file that refers to the instance name so that multiple instances can co-exist.&lt;br /&gt;&lt;br /&gt;To make this conveniently configurable, the above expression does the following:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;The &lt;i&gt;process&lt;/i&gt; parameter specifies the process that needs to be started both in foreground mode and as a daemon. The &lt;i&gt;args&lt;/i&gt; parameter specifies common command-line arguments that both the foreground and daemon process will use.&lt;/li&gt;&lt;li&gt;The &lt;i&gt;foregroundProcessExtraArgs&lt;/i&gt; parameter specifies additional command-line arguments that are only used when the process is started in foreground mode. In the above example, it is used to provide Nginx the global directive that disables the daemon setting.&lt;/li&gt;&lt;li&gt;The &lt;i&gt;daemonExtraArgs&lt;/i&gt; parameter specifies additional command-line arguments that are only used when the process is started as a daemon. In the above example, it used to provide Nginx a global directive with a PID file path that uniquely identifies the process instance.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;For custom software and services implemented in different language than C, e.g. Node.js, Java or Python, it is far less common that they have the ability to daemonize -- they can typically only be used as foreground processes.&lt;br /&gt;&lt;br /&gt;Nonetheless, we can still daemonize foreground-only processes, by using an external tool, such as &lt;a href=&quot;http://www.libslack.org/daemon/&quot;&gt;libslack's &lt;i&gt;daemon&lt;/i&gt;&lt;/a&gt; command:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ daemon -U -i myforegroundprocess&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above command deamonizes the foreground process and creates a PID file for it, so that it can be managed by the sysvinit/BSD rc utility scripts.&lt;br /&gt;&lt;br /&gt;The opposite kind of &quot;simulation&quot; is also possible -- if a process can only be used as a daemon, then we can use a &lt;strong&gt;proxy process&lt;/strong&gt; to make it appear as a foreground process:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto;&quot;&gt;&lt;br /&gt;export _TOP_PID=$$&lt;br /&gt;&lt;br /&gt;# Handle to SIGTERM and SIGINT signals and forward them to the daemon process&lt;br /&gt;_term()&lt;br /&gt;{&lt;br /&gt;    trap &quot;exit 0&quot; TERM&lt;br /&gt;    kill -TERM &quot;$pid&quot;&lt;br /&gt;    kill $_TOP_PID&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;_interrupt()&lt;br /&gt;{&lt;br /&gt;    kill -INT &quot;$pid&quot;&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;trap _term SIGTERM&lt;br /&gt;trap _interrupt SIGINT&lt;br /&gt;&lt;br /&gt;# Start process in the background as a daemon&lt;br /&gt;${executable} &quot;$@&quot;&lt;br /&gt;&lt;br /&gt;# Wait for the PID file to become available.&lt;br /&gt;# Useful to work with daemons that don't behave well enough.&lt;br /&gt;count=0&lt;br /&gt;&lt;br /&gt;while [ ! -f &quot;${_pidFile}&quot; ]&lt;br /&gt;do&lt;br /&gt;    if [ $count -eq 10 ]&lt;br /&gt;    then&lt;br /&gt;        echo &quot;It does not seem that there isn't any pid file! Giving up!&quot;&lt;br /&gt;        exit 1&lt;br /&gt;    fi&lt;br /&gt;&lt;br /&gt;    echo &quot;Waiting for ${_pidFile} to become available...&quot;&lt;br /&gt;    sleep 1&lt;br /&gt;&lt;br /&gt;    ((count=count++))&lt;br /&gt;done&lt;br /&gt;&lt;br /&gt;# Determine the daemon's PID by using the PID file&lt;br /&gt;pid=$(cat ${_pidFile})&lt;br /&gt;&lt;br /&gt;# Wait in the background for the PID to terminate&lt;br /&gt;${if stdenv.isDarwin then ''&lt;br /&gt;  lsof -p $pid +r 3 &amp;amp;&amp;gt;/dev/null &amp;amp;&lt;br /&gt;'' else if stdenv.isLinux || stdenv.isCygwin then ''&lt;br /&gt;  tail --pid=$pid -f /dev/null &amp;amp;&lt;br /&gt; '' else if stdenv.isBSD || stdenv.isSunOS then ''&lt;br /&gt;   pwait $pid &amp;amp;&lt;br /&gt; '' else&lt;br /&gt;   throw &quot;Don't know how to wait for process completion on system: ${stdenv.system}&quot;}&lt;br /&gt;&lt;br /&gt;# Wait for the blocker process to complete.&lt;br /&gt;# We use wait, so that bash can still&lt;br /&gt;# handle the SIGTERM and SIGINT signals that may be sent to it by&lt;br /&gt;# a process manager&lt;br /&gt;blocker_pid=$!&lt;br /&gt;wait $blocker_pid&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The idea of the proxy script shown above is that it runs as a foreground process as long as the daemon process is running and relays any relevant incoming signals (e.g. a terminate and interrupt) to the daemon process.&lt;br /&gt;&lt;br /&gt;Implementing this proxy was a bit tricky:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;In the beginning of the script we configure signal handlers for the &lt;i&gt;TERM&lt;/i&gt; and &lt;i&gt;INT&lt;/i&gt; signals so that the process manager can terminate the daemon process.&lt;/li&gt;&lt;li&gt;We must start the daemon and wait for it to become available. Although the parent process of a well-behaving daemon should only terminate when the initialization is done, this turns out not be a hard guarantee -- to make the process a bit more robust, we deliberately wait for the PID file to become available, before we attempt to wait for the termination of the daemon.&lt;/li&gt;&lt;li&gt;Then we wait for the PID to terminate. The bash shell has an internal &lt;i&gt;wait&lt;/i&gt; command that can be used to wait for a background process to terminate, but this only works with processes in the same process group as the shell. Daemons are in a new session (with different process groups), so they cannot be monitored by the shell by using the &lt;i&gt;wait&lt;/i&gt; command.&lt;br /&gt;&lt;br /&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1058047/wait-for-a-process-to-finish&quot;&gt;From this Stackoverflow article&lt;/a&gt;, I learned that we can use the &lt;i&gt;tail&lt;/i&gt; command of GNU Coreutils, or &lt;i&gt;lsof&lt;/i&gt; on macOS/Darwin, and &lt;i&gt;pwait&lt;/i&gt; on BSDs and Solaris/SunOS to monitor processes in other process groups.&lt;/li&gt;&lt;li&gt;When a command is being executed by a shell script (e.g. in this particular case: &lt;i&gt;tail&lt;/i&gt;, &lt;i&gt;lsof&lt;/i&gt; or &lt;i&gt;pwait&lt;/i&gt;), the shell script can no longer respond to signals until the command completes. To still allow the script to respond to signals while it is waiting for the daemon process to terminate, we must run the previous command in background mode, and we use the &lt;i&gt;wait&lt;/i&gt; instruction to block the script. &lt;a href=&quot;https://unix.stackexchange.com/questions/146756/forward-sigterm-to-child-in-bash&quot;&gt;While a &lt;i&gt;wait&lt;/i&gt; command is running, the shell can respond to signals&lt;/a&gt;.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;The generator function will automatically pick the best solution for the selected target process manager -- this means that when our target process manager are sysvinit or BSD rc scripts, the generator automatically picks the configuration settings to run the process as a daemon. For the remaining process managers, the generator will pick the configuration settings that runs it as a foreground process.&lt;br /&gt;&lt;br /&gt;If a desired process model is not supported, then the generator will automatically simulate it. For instance, if we have a foreground-only process specification, then the generator will automatically configure a sysvinit script to call the &lt;i&gt;daemon&lt;/i&gt; executable to daemonize it.&lt;br /&gt;&lt;br /&gt;A similar process happens when a daemon-only process specification is deployed for a process manager that cannot work with it, such as supervisord.&lt;br /&gt;&lt;br /&gt;&lt;h3&gt;State initialization&lt;/h3&gt;&lt;br /&gt;Another important aspect in process deployment is &lt;strong&gt;state initialization&lt;/strong&gt;. Most system services require the presence of state directories in which they can store their PID, log and temp files. If these directories do not exist, the service may not work and refuse to start.&lt;br /&gt;&lt;br /&gt;To cope with this problem, I typically make processes self initializing -- before starting the process, I check whether the state has been intialized (e.g. check if the state directories exist) and re-initialize the initial state if needed.&lt;br /&gt;&lt;br /&gt;With most process managers, state initialization is easy to facilitate. For sysvinit and BSD rc scripts, we just use the generator to first execute the shell commands to initialize the state before the process gets started.&lt;br /&gt;&lt;br /&gt;Supervisord allows you to execute multiple shell commands in a single &lt;i&gt;command&lt;/i&gt; directive -- we can just execute a script that initializes the state before we execute the process that we want to manage.&lt;br /&gt;&lt;br /&gt;systemd has a &lt;i&gt;ExecStartPre&lt;/i&gt; directive that can be used to specify shell commands to execute before the main process starts.&lt;br /&gt;&lt;br /&gt;Apple launchd and cygrunsrv, however, do not have a generic shell execution mechanism or some facility allowing you to execute things before a process starts. Nonetheless, we can still ensure that the state is going to be initialized by creating a &lt;strong&gt;wrapper script&lt;/strong&gt; -- first the wrapper script does the state initialization and then executes the main process.&lt;br /&gt;&lt;br /&gt;If a state initialization procedure was specified and the target process manager does not support scripting, then the generator function will transparently wrap the main process into a wrapper script that supports state initialization.&lt;br /&gt;&lt;br /&gt;&lt;h3&gt;Process dependencies&lt;/h3&gt;&lt;br /&gt;Another important generic concept is process dependency management. For example, Nginx can act as a reverse proxy for another web application process. To provide a functional Nginx service, we must be sure that the web application process gets activated as well, and that the web application is activated before Nginx.&lt;br /&gt;&lt;br /&gt;If the web application process is activated after Nginx or missing completely, then Nginx is (temporarily) unable to redirect incoming requests to the web application process causing end-users to see bad gateway errors.&lt;br /&gt;&lt;br /&gt;The process managers that I have experimented with all have a different notion of process dependencies.&lt;br /&gt;&lt;br /&gt;sysvinit scripts can optionally declare dependencies in their comment sections. Tools that know how to interpret these dependency specifications can use it to decide the right activation order. Systems using sysvinit typically ignore this specification. Instead, they work with sequence numbers in their file names -- each run level configuration directory contains a prefix (S or K) followed by two numeric digits that defines the start or stop order.&lt;br /&gt;&lt;br /&gt;supervisord does not work with dependency specifications, but every program can optionally provide a &lt;i&gt;priority&lt;/i&gt; setting that can be used to order the activation and deactivation of programs -- lower priority numbers have precedence over high priority numbers.&lt;br /&gt;&lt;br /&gt;From dependency specifications in a process management expression, the generator function can automatically derive sequence numbers for process managers that require it.&lt;br /&gt;&lt;br /&gt;Similar to sysvinit scripts, BSD rc scripts can also declare dependencies in their comment sections. Contrary to sysvinit scripts, BSD rc scripts can use the &lt;a href=&quot;https://www.freebsd.org/cgi/man.cgi?rcorder(8)&quot;&gt;&lt;i&gt;rcorder&lt;/i&gt;&lt;/a&gt; tool to parse these dependencies from the comments section and automatically derive the order in which the BSD rc scripts need to be activated.&lt;br /&gt;&lt;br /&gt;&lt;i&gt;cygrunsrv&lt;/i&gt; also allows you directly specify process dependencies. The Windows service manager makes sure that the service get activated in the right order and that all process dependencies are activated first. The only limitation is that cygrunsrv only allows up to 16 dependencies to be specified per service.&lt;br /&gt;&lt;br /&gt;To simulate process dependencies with systemd, we can use two properties. The &lt;i&gt;Wants&lt;/i&gt; property can be used to tell systemd that another service needs to be activated first. The &lt;i&gt;After&lt;/i&gt; property can be used to specify the ordering.&lt;br /&gt;&lt;br /&gt;Sadly, it seems that launchd has no notion of process dependencies at all -- processes can be activated by certain events, e.g. when a kernel module was loaded or through socket activation, but it does not seem to have the ability to configure process dependencies or the activation ordering. When our target process manager is launchd, then we simply have to inform the user that proper activation ordering cannot be guaranteed.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Changing user privileges&lt;/h2&gt;&lt;br /&gt;Another general concept, that has subtle differences in each process manager, is changing user privileges. Typically for the deployment of system services, you do not want to run these services as root user (that has full access to the filesystem), but as an unprivileged user.&lt;br /&gt;&lt;br /&gt;sysvinit and BSD rc scripts have to change users through the &lt;i&gt;su&lt;/i&gt; command. The &lt;i&gt;su&lt;/i&gt; command can be used to change the user ID (UID), and will automatically adopt the primary group ID (GID) of the corresponding user.&lt;br /&gt;&lt;br /&gt;Supervisord and &lt;i&gt;cygrunsrv&lt;/i&gt; can also only change user IDs (UIDs), and will adopt the primary group ID (GID) of the corresponding user.&lt;br /&gt;&lt;br /&gt;Systemd and launchd can both change the user IDs and group IDs of the process that it invokes.&lt;br /&gt;&lt;br /&gt;Because only changing UIDs are universally supported amongst process managers, I did not add a configuration property that allows you to change GIDs in a process manager-agnostic way.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Deploying process manager-agnostic configurations&lt;/h2&gt;&lt;br /&gt;With a processes Nix expression, we can define which process instances we want to run (and how they can be constructed from source code and their dependencies):&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;{ pkgs ? import  { inherit system; }&lt;br /&gt;, system ? builtins.currentSystem&lt;br /&gt;, stateDir ? &quot;/var&quot;&lt;br /&gt;, runtimeDir ? &quot;${stateDir}/run&quot;&lt;br /&gt;, logDir ? &quot;${stateDir}/log&quot;&lt;br /&gt;, tmpDir ? (if stateDir == &quot;/var&quot; then &quot;/tmp&quot; else &quot;${stateDir}/tmp&quot;)&lt;br /&gt;, forceDisableUserChange ? false&lt;br /&gt;, processManager&lt;br /&gt;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  constructors = import ./constructors.nix {&lt;br /&gt;    inherit pkgs stateDir runtimeDir logDir tmpDir;&lt;br /&gt;    inherit forceDisableUserChange processManager;&lt;br /&gt;  };                                                                                                                                                                                               &lt;br /&gt;in                                                                                                                                                                                                 &lt;br /&gt;rec {                                                                                                                                                                                              &lt;br /&gt;  webapp = rec {                                                                                                                                                                                   &lt;br /&gt;    port = 5000;                                                                                                                                                                                   &lt;br /&gt;    dnsName = &quot;webapp.local&quot;;                                                                                                                                                                      &lt;br /&gt;                                                                                                                                                                                                   &lt;br /&gt;    pkg = constructors.webapp {                                                                                                                                                                    &lt;br /&gt;      inherit port;                                                                                                                                                                                &lt;br /&gt;    };                                                                                                                                                                                             &lt;br /&gt;  };                                                                                                                                                                                               &lt;br /&gt;                                                                                                                                                                                                   &lt;br /&gt;  nginxReverseProxy = rec {&lt;br /&gt;    port = 8080;&lt;br /&gt;&lt;br /&gt;    pkg = constructors.nginxReverseProxy {&lt;br /&gt;      webapps = [ webapp ];&lt;br /&gt;      inherit port;&lt;br /&gt;    } {};&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;In the above Nix expression, we compose two running process instances:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;&lt;i&gt;webapp&lt;/i&gt; is a trivial web application process that will simply return a static HTML page by using the HTTP protocol.&lt;/li&gt;&lt;li&gt;&lt;i&gt;nginxReverseProxy&lt;/i&gt; is a Nginx server configured as a reverse proxy server. It will forward incoming HTTP requests to the appropriate web application instance, based on the virtual host name. If a virtual host name is &lt;i&gt;webapp.local&lt;/i&gt;, then Nginx forwards the request to the &lt;i&gt;webapp&lt;/i&gt; instance.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;To generate the configuration artifacts for the process instances, we refer to a separate constructors Nix expression. Each constructor will call the &lt;i&gt;createManagedProcess&lt;/i&gt; function abstraction (as shown earlier) to construct a process configuration in a process manager-agnostic way.&lt;br /&gt;&lt;br /&gt;With the following command-line instruction, we can generate sysvinit scripts for the &lt;i&gt;webapp&lt;/i&gt; and Nginx processes declared in the processes expression, and run them as an unprivileged user with the state files managed in our home directory:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ nixproc-build --process-manager sysvinit \&lt;br /&gt;  --state-dir /home/sander/var \&lt;br /&gt;  --force-disable-user-change processes.nix&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;By adjusting the &lt;i&gt;--process-manager&lt;/i&gt; parameter we can also generate artefacts for a different process manager. For example, the following command will generate systemd unit config files instead of sysvinit scripts:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ nixproc-build --process-manager systemd \&lt;br /&gt;  --state-dir /home/sander/var \&lt;br /&gt;  --force-disable-user-change processes.nix&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The following command will automatically build and deploy all processes, using sysvinit as a process manager:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ nixproc-sysvinit-switch --state-dir /home/sander/var \&lt;br /&gt;  --force-disable-user-change processes.nix&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;We can also run a life-cycle management activity on all previously deployed processes. For example, to retrieve the statuses of all processes, we can run:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ nixproc-sysvinit-runactivity status&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;We can also traverse the processes in reverse dependency order. This is particularly useful to reliably stop all processes, without breaking any process dependencies:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ nixproc-sysvinit-runactivity -r stop&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;Similarly, there are command-line tools to use the other supported process managers. For example, to deploy systemd units instead of sysvinit scripts, you can run:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ nixproc-systemd-switch processes.nix&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;h2&gt;Distributed process manager-agnostic deployment with Disnix&lt;/h2&gt;&lt;br /&gt;As shown in the previous process management framework blog post, it is also possible to deploy processes to machines in a network and have inter-dependencies between processes. These kinds of deployments can be managed by &lt;a href=&quot;https://sandervanderburg.blogspot.com/2011/02/disnix-toolset-for-distributed.html&quot;&gt;Disnix&lt;/a&gt;.&lt;br /&gt;&lt;br /&gt;Compared to the previous blog post (in which we could only deploy sysvinit scripts), we can now also use any process manager that the framework supports. The Dysnomia toolset provides plugins that supports all process managers that this framework supports:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;{ pkgs, distribution, invDistribution, system&lt;br /&gt;, stateDir ? &quot;/var&quot;&lt;br /&gt;, runtimeDir ? &quot;${stateDir}/run&quot;&lt;br /&gt;, logDir ? &quot;${stateDir}/log&quot;&lt;br /&gt;, tmpDir ? (if stateDir == &quot;/var&quot; then &quot;/tmp&quot; else &quot;${stateDir}/tmp&quot;)&lt;br /&gt;, forceDisableUserChange ? false&lt;br /&gt;, processManager ? &quot;sysvinit&quot;&lt;br /&gt;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  constructors = import ./constructors.nix {&lt;br /&gt;    inherit pkgs stateDir runtimeDir logDir tmpDir;&lt;br /&gt;    inherit forceDisableUserChange processManager;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  processType =&lt;br /&gt;    if processManager == &quot;sysvinit&quot; then &quot;sysvinit-script&quot;&lt;br /&gt;    else if processManager == &quot;systemd&quot; then &quot;systemd-unit&quot;&lt;br /&gt;    else if processManager == &quot;supervisord&quot; then &quot;supervisord-program&quot;&lt;br /&gt;    else if processManager == &quot;bsdrc&quot; then &quot;bsdrc-script&quot;&lt;br /&gt;    else if processManager == &quot;cygrunsrv&quot; then &quot;cygrunsrv-service&quot;&lt;br /&gt;    else throw &quot;Unknown process manager: ${processManager}&quot;;&lt;br /&gt;in&lt;br /&gt;rec {&lt;br /&gt;  webapp = rec {&lt;br /&gt;    name = &quot;webapp&quot;;&lt;br /&gt;    port = 5000;&lt;br /&gt;    dnsName = &quot;webapp.local&quot;;&lt;br /&gt;    pkg = constructors.webapp {&lt;br /&gt;      inherit port;&lt;br /&gt;    };&lt;br /&gt;    type = processType;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  nginxReverseProxy = rec {&lt;br /&gt;    name = &quot;nginxReverseProxy&quot;;&lt;br /&gt;    port = 8080;&lt;br /&gt;    pkg = constructors.nginxReverseProxy {&lt;br /&gt;      inherit port;&lt;br /&gt;    };&lt;br /&gt;    dependsOn = {&lt;br /&gt;      inherit webapp;&lt;br /&gt;    };&lt;br /&gt;    type = processType;&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;In the above expression, we have extended the previously shown processes expression into a Disnix service expression, in which every attribute in the attribute set represents a service that can be distributed to a target machine in the network.&lt;br /&gt;&lt;br /&gt;The &lt;i&gt;type&lt;/i&gt; attribute of each service indicates which Dysnomia plugin needs to manage its life-cycle. We can automatically select the appropriate plugin for our desired process manager by deriving it from the &lt;i&gt;processManager&lt;/i&gt; parameter.&lt;br /&gt;&lt;br /&gt;The above Disnix expression has a drawback -- in a &lt;strong&gt;heteregenous network&lt;/strong&gt; of machines (that run multiple operating systems and/or process managers), we need to compose all desired variants of each service with configuration files for each process manager that we want to use.&lt;br /&gt;&lt;br /&gt;It is also possible to have &lt;strong&gt;target-agnostic&lt;/strong&gt; services, by delegating the translation steps to the corresponding target machines. Instead of directly generating a configuration file for a process manager, we generate a JSON specification containing all parameters that are passed to &lt;i&gt;createManagedProcess&lt;/i&gt;. We can use this JSON file to build the corresponding configuration artefacts on the target machine:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;{ pkgs, distribution, invDistribution, system&lt;br /&gt;, stateDir ? &quot;/var&quot;&lt;br /&gt;, runtimeDir ? &quot;${stateDir}/run&quot;&lt;br /&gt;, logDir ? &quot;${stateDir}/log&quot;&lt;br /&gt;, tmpDir ? (if stateDir == &quot;/var&quot; then &quot;/tmp&quot; else &quot;${stateDir}/tmp&quot;)&lt;br /&gt;, forceDisableUserChange ? false&lt;br /&gt;, processManager ? null&lt;br /&gt;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  constructors = import ./constructors.nix {&lt;br /&gt;    inherit pkgs stateDir runtimeDir logDir tmpDir;&lt;br /&gt;    inherit forceDisableUserChange processManager;&lt;br /&gt;  };&lt;br /&gt;in&lt;br /&gt;rec {&lt;br /&gt;  webapp = rec {&lt;br /&gt;    name = &quot;webapp&quot;;&lt;br /&gt;    port = 5000;&lt;br /&gt;    dnsName = &quot;webapp.local&quot;;&lt;br /&gt;    pkg = constructors.webapp {&lt;br /&gt;      inherit port;&lt;br /&gt;    };&lt;br /&gt;    type = &quot;managed-process&quot;;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  nginxReverseProxy = rec {&lt;br /&gt;    name = &quot;nginxReverseProxy&quot;;&lt;br /&gt;    port = 8080;&lt;br /&gt;    pkg = constructors.nginxReverseProxy {&lt;br /&gt;      inherit port;&lt;br /&gt;    };&lt;br /&gt;    dependsOn = {&lt;br /&gt;      inherit webapp;&lt;br /&gt;    };&lt;br /&gt;    type = &quot;managed-process&quot;;&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;In the above services model, we have set the &lt;i&gt;processManager&lt;/i&gt; parameter to &lt;i&gt;null&lt;/i&gt; causing the generator to print JSON presentations of the function parameters passed to &lt;i&gt;createManagedProcess&lt;/i&gt;.&lt;br /&gt;&lt;br /&gt;The &lt;i&gt;managed-process&lt;/i&gt; type refers to a Dysnomia plugin that consumes the JSON specification and invokes the &lt;i&gt;createManagedProcess&lt;/i&gt; function to convert the JSON configuration to a configuration file used by the preferred process manager.&lt;br /&gt;&lt;br /&gt;In the infrastructure model, we can configure the preferred process manager for each target machine:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;{&lt;br /&gt;  test1 = {&lt;br /&gt;    properties = {&lt;br /&gt;      hostname = &quot;test1&quot;;&lt;br /&gt;    };&lt;br /&gt;    containers = {&lt;br /&gt;      managed-process = {&lt;br /&gt;        processManager = &quot;sysvinit&quot;;&lt;br /&gt;      };&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  test2 = {&lt;br /&gt;    properties = {&lt;br /&gt;      hostname = &quot;test2&quot;;&lt;br /&gt;    };&lt;br /&gt;    containers = {&lt;br /&gt;      managed-process = {&lt;br /&gt;        processManager = &quot;systemd&quot;;&lt;br /&gt;      };&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;In the above infrastructure model, the &lt;i&gt;managed-proces&lt;/i&gt; container on the first machine: &lt;i&gt;test1&lt;/i&gt; has been configured to use sysvinit scripts to manage processes. On the second test machine: &lt;i&gt;test2&lt;/i&gt; the &lt;i&gt;managed-process&lt;/i&gt; container is configured to use systemd to manage processes.&lt;br /&gt;&lt;br /&gt;If we distribute the services in the services model to targets in the infrastructure model as follows:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;{infrastructure}:&lt;br /&gt;&lt;br /&gt;{&lt;br /&gt;  webapp = [ infrastructure.test1 ];&lt;br /&gt;  nginxReverseProxy = [ infrastructure.test2 ];&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;and the deploy the system as follows:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto; font-size: 90%;&quot;&gt;&lt;br /&gt;$ disnix-env -s services.nix -i infrastructure.nix -d distribution.nix&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;Then the &lt;i&gt;webapp&lt;/i&gt; process will distributed to the &lt;i&gt;test1&lt;/i&gt; machine in the network and will be managed with a sysvinit script.&lt;br /&gt;&lt;br /&gt;The &lt;i&gt;nginxReverseProxy&lt;/i&gt; will be deployed to the &lt;i&gt;test2&lt;/i&gt; machine and managed as a systemd job. The Nginx reverse proxy forwards incoming connections to the &lt;i&gt;webapp.local&lt;/i&gt; domain name to the web application process hosted on the first machine.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Discussion&lt;/h2&gt;&lt;br /&gt;In this blog post, I have introduced a process manager-agnostic function abstraction making it possible to target all kinds of process managers on a variety of operating systems.&lt;br /&gt;&lt;br /&gt;By using a single set of declarative specifications, we can:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Target six different process managers on four different kinds of operating systems.&lt;/li&gt;&lt;li&gt;Implement various kinds of deployment scenarios: production deployments, test deployments as an unprivileged user.&lt;/li&gt;&lt;li&gt;Construct multiple instances of processes.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;In a distributed-context, the advantage is that we can uniformly target all supported process managers and operating systems in a heterogeneous environment from a single declarative specification.&lt;br /&gt;&lt;br /&gt;This is particularly useful to facilitate technology diversity -- for example, one of the key selling points of Microservices is that &quot;any technology&quot; can be used to implement them. In many cases, technology diversity is &quot;restricted&quot; to frameworks, programming languages, and storage technologies.&lt;br /&gt;&lt;br /&gt;One particular aspect that is rarely changed is the choice of operating systems, because of the limitations of deployment tools -- most deployment solutions for Microservices are container-based and heavily rely on Linux-only concepts, such as Namespaces and cgroups.&lt;br /&gt;&lt;br /&gt;With this process managemenent framework and the recent Dysnomia plugin additions for Disnix, it is possible to target all kinds of operating systems that support the Nix package manager, making the operating system component selectable as well. This, for example, allows you to also pick the best operating system to implement a certain requirement -- for example, when performance is important you might pick Linux, and when there is a strong emphasis on security, you could pick OpenBSD to host a mission criticial component.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Limitations&lt;/h2&gt;&lt;br /&gt;The following table, summarizes the differences between the process manager solutions that I have investigated:&lt;br /&gt;&lt;br /&gt;&lt;div&gt;&lt;table style=&quot;border-style: solid; border-width: 1px;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;th style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;sysvinit&lt;/th&gt;&lt;th style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;bsdrc&lt;/th&gt;&lt;th style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;supervisord&lt;/th&gt;&lt;th style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;systemd&lt;/th&gt;&lt;th style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;launchd&lt;/th&gt;&lt;th style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;cygrunsrv&lt;/th&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;Process type&lt;/th&gt;&lt;td style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;daemon&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;daemon&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;foreground&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;foreground&lt;br /&gt;daemon&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;foreground&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;foreground&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;Process control method&lt;/th&gt;&lt;td style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;PID files&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;PID files&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;Process PID&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;cgroups&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;Process PID&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;Process PID&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;Scripting support&lt;/th&gt;&lt;td style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;yes&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;yes&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;yes&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;yes&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;no&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;no&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;Process dependency management&lt;/th&gt;&lt;td style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;Numeric ordering&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;Dependency-based&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;Numeric ordering&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;Dependency-based&lt;br /&gt;+ dependency loading&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;None&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;Dependency-based&lt;br /&gt;+ dependency loading&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;User changing capabilities&lt;/th&gt;&lt;td style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;user&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;user&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;user and group&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;user and group&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;user and group&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;user&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;Unprivileged user deployments&lt;/th&gt;&lt;td style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;yes*&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;yes*&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;yes&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;yes*&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;no&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;no&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;Operating system support&lt;/th&gt;&lt;td style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;Linux&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;FreeBSD&lt;br /&gt; &amp;gt;OpenBSD&lt;br /&gt;NetBSD&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;Many UNIX-like:&lt;br /&gt;Linux&lt;br /&gt;macOS&lt;br /&gt;FreeBSD&lt;br /&gt;Solaris&lt;br /&gt;&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;Linux (+glibc) only&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;macOS (Darwin)&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px; white-space: nowrap;&quot;&gt;Windows (Cygwin)&lt;/td&gt;&lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;br /&gt;Although we can facilitate lifecycle management from a common specification with a variety of process managers, only the most important common features are supported.&lt;br /&gt;&lt;br /&gt;Not every concept can be done in a process manager agnostic way. For example, we cannot generically do any isolation of resources (except for packages, because we use Nix). It is difficult to generalize these concepts because these they are not standardized, e.g. the POSIX standard does not descibe namespaces and cgroups (or similar concepts).&lt;br /&gt;&lt;br /&gt;Furthermore, most process managers (with the exception of supervisord) are operating system specific. As a result, it still matters what process manager is picked.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Related work&lt;/h2&gt;&lt;br /&gt;Process manager-agnostic deployment is not entirely a new idea. Dysnomia already has a target-agnostic 'process' plugin for quite a while, that translates a simple deployment specification (constisting of key-value pairs) to a systemd unit configuration file or sysvinit script.&lt;br /&gt;&lt;br /&gt;The features of Dysnomia's &lt;i&gt;process&lt;/i&gt; plugin are much more limited compared to the &lt;i&gt;createManagedProcess&lt;/i&gt; abstraction function described in this blog post. It does not support any other than process managers than sysvint and systemd, and it can only work with foreground processes.&lt;br /&gt;&lt;br /&gt;Furthermore, target agnostic configurations cannot be easily extended -- it is possible to (ab)use the templating mechanism, but it has no first class overridde facilities.&lt;br /&gt;&lt;br /&gt;I also found a project called &lt;a href=&quot;https://github.com/jordansissel/pleaserun&quot;&gt;pleaserun&lt;/a&gt; that also has the objective to generate configuration files for a variety of process managers (my approach and pleaserunit, both support sysvinit scripts, systemd and launchd).&lt;br /&gt;&lt;br /&gt;It seems to use template files to generate the configuration artefacts, and it does not seem to have a generic extension mechanism. Furthermore, it provides no framework to configure the location of shared resources, automatically install package dependencies or to compose multiple instances of processes.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Some remaining thoughts&lt;/h2&gt;&lt;br /&gt;Although the Nix package manager (not the NixOS distribution), should be portable amongst a variety of UNIX-like systems, it turns out that the only two operating systems that are well supported are Linux and macOS. Nix was reported to work on a variety of other UNIX-like systems in the past, but recently it seems that many things are broken.&lt;br /&gt;&lt;br /&gt;To make Nix work on FreeBSD 12.1, I have used the latest stable Nix package manager version &lt;a href=&quot;https://github.com/0mp/freebsd-ports-nix&quot;&gt;with patches from this repository&lt;/a&gt;. It turns out that there is still a patch missing to work around in a bug in FreeBSD that incorrectly kills all processes in a process group. Fortunately, when we run Nix as as unprivileged user, this bug does not seem to cause any serious problems.&lt;br /&gt;&lt;br /&gt;Recent versions of Nixpkgs turn out to be horribly broken on FreeBSD -- the FreeBSD stdenv does not seem to work at all. I tried switching back to stdenv-native (a &lt;i&gt;stdenv&lt;/i&gt; environment that impurely uses the host system's compiler and core executables), but that also no longer seems to work in the last three major releases -- the Nix expression evaluation breaks in several places. Due to the intense amount of changes and assumptions that the &lt;i&gt;stdenv&lt;/i&gt; infrastructure currently makes, it was as good as impossible for me to fix the infrastructure.&lt;br /&gt;&lt;br /&gt;As another workaround, I reverted back very to a very old version of Nixpkgs (version 17.03 to be precise), that still has a working stdenv-native environment. With some tiny adjustments (e.g. adding some shell aliases for some GNU variants of certain shell executables to &lt;i&gt;stdenv-native&lt;/i&gt;), I have managed to get some basic Nix packages working, including Nginx on FreeBSD.&lt;br /&gt;&lt;br /&gt;Surprisingly, running Nix on Cygwin was less painful than FreeBSD (because of all the GNUisms that Cygwin provides). Similar to FreeBSD, recent versions of Nixpkgs also appear to be broken, including the Cygwin stdenv environment. By reverting back to &lt;i&gt;release-18.03&lt;/i&gt; (that still has a somewhat working &lt;i&gt;stdenv&lt;/i&gt; for Cygwin), I have managed to build a working Nginx version.&lt;br /&gt;&lt;br /&gt;As a future improvement to Nixpkgs, I would like to propose a testing solution for stdenv-native. Although I understand that is difficult to dedicate manpower to maintain all unconventional Nix/Nixpkgs ports, stdenv-native is something that we can also convienently test on Linux and prevent from breaking in the future.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Availability&lt;/h2&gt;&lt;br /&gt;&lt;a href=&quot;https://github.com/svanderburg/nix-processmgmt&quot;&gt;The latest version of my experimental Nix-based process framework&lt;/a&gt;, that includes the process manager-agnostic configuration function described in this blog post, can be obtained from my GitHub page.&lt;br /&gt;&lt;br /&gt;In addition, the repository also contains some example cases, including the web application system described in this blog post, and a set of common system services: MySQL, Apache HTTP server, PostgreSQL and Apache Tomcat.&lt;br /&gt;&lt;br /&gt;</description>
	<pubDate>Sat, 15 Feb 2020 20:07:00 +0000</pubDate>
	<author>noreply@blogger.com (Sander van der Burg)</author>
</item>
<item>
	<title>Cachix: CDN and double storage size</title>
	<guid isPermaLink="true">https://blog.cachix.org/post/2020-01-28-cdn-and-double-storage/</guid>
	<link>https://blog.cachix.org/post/2020-01-28-cdn-and-double-storage/</link>
	<description>Cachix - Nix binary cache hosting, has grown quite a bit in recent months in terms of day to day usage and that was mostly noticable on bandwidth.
Over 3000 GB were served in December 2019.
CDN by CloudFlare Increased usage prompted a few backend machine instance upgrades to handle concurrent upload/downloads, but it became clear it’s time to abandon single machine infrastructure.
As of today, all binary caches are served by CloudFlare CDN.</description>
	<pubDate>Wed, 29 Jan 2020 08:00:00 +0000</pubDate>
	<author>support@cachix.org (Domen Kožar)</author>
</item>
<item>
	<title>Mayflower: __structuredAttrs in Nix</title>
	<guid isPermaLink="true">https://nixos.mayflower.consulting/blog/2020/01/20/structured-attrs/</guid>
	<link>https://nixos.mayflower.consulting/blog/2020/01/20/structured-attrs/</link>
	<description>In Nix 2 a new parameter to the derivation primitive was added. It changes how information is passed to the derivation builder.
Current State In order to show how it changes the handling of parameters to derivation, the first example will show the current state with __structuredAttrs set to false and the stdenv.mkDerivation wrapper around derivation. All parameters are passed to the builder as environment variables, canonicalised by Nix in imitation of shell script conventions:</description>
	<pubDate>Mon, 20 Jan 2020 12:00:00 +0000</pubDate>
</item>
<item>
	<title>Hercules Labs: Hercules CI &amp; Cachix split up</title>
	<guid isPermaLink="true">https://blog.hercules-ci.com/2020/01/14/hercules-ci-cachix-split-up/</guid>
	<link>https://blog.hercules-ci.com/2020/01/14/hercules-ci-cachix-split-up/</link>
	<description>&lt;p&gt;After careful consideration of how to balance between the two products, we’ve decided to split up. Each of the two products will be a separate entity:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Hercules CI becomes part of Robert Hensing’s Ensius B.V.&lt;/li&gt;
  &lt;li&gt;Cachix becomes part of Domen Kožar’s Enlambda OÜ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For customers there will be no changes, except for the point of contact in support requests.&lt;/p&gt;

&lt;p&gt;Domen &amp;amp; Robert&lt;/p&gt;</description>
	<pubDate>Tue, 14 Jan 2020 00:00:00 +0000</pubDate>
</item>
<item>
	<title>Mayflower: Windows-on-NixOS, part 1: Migrating bare-metal to a VM</title>
	<guid isPermaLink="true">https://nixos.mayflower.consulting/blog/2019/11/27/windows-vm-storage/</guid>
	<link>https://nixos.mayflower.consulting/blog/2019/11/27/windows-vm-storage/</link>
	<description>This is part 1 of a series of blog posts explaining how we took an existing Windows installation on hardware and moved it into a VM running on top of NixOS.
Background We have a decently-equipped desktop PC sitting in our office, which is designated for data experiments using TensorFlow and such. During off-hours, it's also used for games, and for that purpose it has Windows installed on it. We decided to try moving Windows into a VM within NixOS so that we could run both operating systems in parallel.</description>
	<pubDate>Wed, 27 Nov 2019 06:00:00 +0000</pubDate>
</item>
<item>
	<title>Craige McWhirter: Deploying and Configuring Vim on NixOS</title>
	<guid isPermaLink="true">http://mcwhirter.com.au//craige/blog/2019/Deploying_and_Configuring_Vim_on_NixOS/</guid>
	<link>http://mcwhirter.com.au//craige/blog/2019/Deploying_and_Configuring_Vim_on_NixOS/</link>
	<description>&lt;p&gt;&lt;img alt=&quot;NixOS Gears by Craige McWhirter&quot; src=&quot;http://mcwhirter.com.au/files/NixOS_Gears.png&quot; title=&quot;NixOS Gears by Craige McWhirter&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I had a need to deploy &lt;a href=&quot;https://www.vim.org/&quot;&gt;vim&lt;/a&gt; and my particular preferred
configuration both system-wide and across multiple systems (via
&lt;a href=&quot;https://nixos.org/nixops/&quot;&gt;NixOps&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;I started by creating a file named &lt;code&gt;vim.nix&lt;/code&gt; that would be imported into either
&lt;code&gt;/etc/nixos/configuration.nix&lt;/code&gt; or an appropriate NixOps Nix file. This example
is a stub that shows a number of common configuration items:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://source.mcwhirter.io/craige/nixos-examples/src/branch/master/applications/editors/vim.nix&quot;&gt;vim.nix&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;nix&quot;&gt;with import &amp;lt;nixpkgs&amp;gt; {};

vim_configurable.customize {
  name = &quot;vim&quot;;   # Specifies the vim binary name.
  # Below you can specify what usually goes into `~/.vimrc`
  vimrcConfig.customRC = ''
    &quot; Preferred global default settings:
    set number                    &quot; Enable line numbers by default
    set background=dark           &quot; Set the default background to dark or light
    set smartindent               &quot; Automatically insert extra level of indentation
    set tabstop=4                 &quot; Default tabstop
    set shiftwidth=4              &quot; Default indent spacing
    set expandtab                 &quot; Expand [TABS] to spaces
    syntax enable                 &quot; Enable syntax highlighting
    colorscheme solarized         &quot; Set the default colour scheme
    set t_Co=256                  &quot; use 265 colors in vim
    set spell spelllang=en_au     &quot; Default spell checking language
    hi clear SpellBad             &quot; Clear any unwanted default settings
    hi SpellBad cterm=underline   &quot; Set the spell checking highlight style
    hi SpellBad ctermbg=NONE      &quot; Set the spell checking highlight background
    match ErrorMsg '\s\+$'        &quot;

    let g:airline_powerline_fonts = 1   &quot; Use powerline fonts
    let g:airline_theme='solarized'     &quot; Set the airline theme

    set laststatus=2   &quot; Set up the status line so it's coloured and always on

    &quot; Add more settings below
  '';
  # store your plugins in Vim packages
  vimrcConfig.packages.myVimPackage = with pkgs.vimPlugins; {
    start = [               # Plugins loaded on launch
      airline               # Lean &amp;amp; mean status/tabline for vim that's light as air
      solarized             # Solarized colours for Vim
      vim-airline-themes    # Collection of themes for airlin
      vim-nix               # Support for writing Nix expressions in vim
    ];
    # manually loadable by calling `:packadd $plugin-name`
    # opt = [ phpCompletion elm-vim ];
    # To automatically load a plugin when opening a filetype, add vimrc lines like:
    # autocmd FileType php :packadd phpCompletion
  };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I then needed to import this file into my system packages stanza:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;nix&quot;&gt;  environment = {
    systemPackages = with pkgs; [
      someOtherPackages   # Normal package listing
      (
        import ./vim.nix
      )
    ];
  };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will then install and configure Vim as you've defined it.&lt;/p&gt;

&lt;p&gt;If you'd like to give this build a run in a non-production space, I've written &lt;a href=&quot;https://source.mcwhirter.io/craige/nixos-examples/src/branch/master/applications/editors/vim_vm.nix&quot;&gt;vim_vm.nix&lt;/a&gt; with which you can build a VM, ssh into afterwards and test the Vim configuration:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ nix-build '&amp;lt;nixpkgs/nixos&amp;gt;' -A vm --arg configuration ./vim_vm.nix
...
$ export QEMU_OPTS=&quot;-m 4192&quot;
$ export QEMU_NET_OPTS=&quot;hostfwd=tcp::18080-:80,hostfwd=tcp::10022-:22&quot;
$ ./result/bin/run-vim-vm-vm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, from a another terminal:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ ssh nixos@localhost -p 10022
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And you should be in a freshly baked NixOS VM with your Vim config ready to be
used.&lt;/p&gt;

&lt;p&gt;There's an always current example of my &lt;a href=&quot;https://source.mcwhirter.io/craige/mio-ops/src/branch/master/roles/vim.nix&quot;&gt;production Vim
configuration&lt;/a&gt;
in my &lt;a href=&quot;https://source.mcwhirter.io/craige/mio-ops/&quot;&gt;mio-ops&lt;/a&gt; repo.&lt;/p&gt;</description>
	<pubDate>Thu, 14 Nov 2019 04:18:37 +0000</pubDate>
</item>
<item>
	<title>Hercules Labs: Hercules CI Agent 0.6.1</title>
	<guid isPermaLink="true">https://blog.hercules-ci.com/2019/11/12/hercules-ci-agent-0.6.1-release/</guid>
	<link>https://blog.hercules-ci.com/2019/11/12/hercules-ci-agent-0.6.1-release/</link>
	<description>&lt;p&gt;We’ve released &lt;a href=&quot;https://github.com/hercules-ci/hercules-ci-agent/releases/tag/hercules-ci-agent-0.6.1&quot;&gt;hercules-ci-agent 0.6.1&lt;/a&gt;, days after &lt;a href=&quot;https://github.com/hercules-ci/hercules-ci-agent/releases/tag/hercules-ci-agent-0.6.0&quot;&gt;0.6.0&lt;/a&gt; release.&lt;/p&gt;

&lt;p&gt;Everyone is encouraged to upgrade, as it brings performance improvements, a bugfix to IFD and better onboarding experience.&lt;/p&gt;

&lt;h3 id=&quot;061---2019-11-06&quot;&gt;0.6.1 - 2019-11-06&lt;/h3&gt;

&lt;h3 id=&quot;fixed&quot;&gt;Fixed&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Fix token leak to system log when reporting an HTTP exception. This was introduced by a library upgrade.
This was discovered after tagging 0.6.0 but before the release was
announced and before moving of the &lt;code class=&quot;highlighter-rouge&quot;&gt;stable&lt;/code&gt; branch.
Only users of the &lt;code class=&quot;highlighter-rouge&quot;&gt;hercules-ci-agent&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; branch and the unannounced
tag were exposed to this leak.
We recommend to follow the &lt;code class=&quot;highlighter-rouge&quot;&gt;stable&lt;/code&gt; branch.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Temporarily revert a Nix GC configuration change that might cause problems
until agent gc root behavior is improved.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;060---2019-11-04&quot;&gt;0.6.0 - 2019-11-04&lt;/h3&gt;

&lt;h3 id=&quot;changed&quot;&gt;Changed&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Switch to Nix 2.3 and NixOS 19.09. &lt;em&gt;You should update your deployment to reflect the NixOS upgrade&lt;/em&gt;, unless you’re using terraform or nix-darwin, where it’s automatic.&lt;/li&gt;
  &lt;li&gt;Increased parallellism during push to cachix&lt;/li&gt;
  &lt;li&gt;Switch to NixOS 19.09&lt;/li&gt;
  &lt;li&gt;Enable min-free/max-free Nix GC&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;fixed-1&quot;&gt;Fixed&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Transient errors during source code fetching are now retried&lt;/li&gt;
  &lt;li&gt;Fixed a bug related to narinfo caching in the context of IFD&lt;/li&gt;
  &lt;li&gt;Fixed an exception when the root of ci.nix is a list, although lists are unsupported&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;what-we-do&quot;&gt;What we do&lt;/h2&gt;

&lt;p&gt;Automated hosted infrastructure for Nix, reliable and reproducible developer tooling,
to speed up adoption and lower integration cost. We offer
&lt;a href=&quot;https://hercules-ci.com&quot;&gt;Continuous Integration&lt;/a&gt; and &lt;a href=&quot;https://cachix.org&quot;&gt;Binary Caches&lt;/a&gt;.&lt;/p&gt;</description>
	<pubDate>Tue, 12 Nov 2019 00:00:00 +0000</pubDate>
</item>
<item>
	<title>Sander van der Burg: A Nix-based functional organization for managing processes</title>
	<guid isPermaLink="false">tag:blogger.com,1999:blog-1397115249631682228.post-7384934454548345241</guid>
	<link>http://sandervanderburg.blogspot.com/2019/11/a-nix-based-functional-organization-for.html</link>
	<description>The &lt;a href=&quot;https://sandervanderburg.blogspot.com/2012/11/an-alternative-explaination-of-nix.html&quot;&gt;Nix expression language&lt;/a&gt; and the Nix packages repository follow a number of unorthodox, but simple conventions that provide all kinds of benefits, such as the ability to conveniently construct multiple variants of packages and store them safely in isolation without any conflicts.&lt;br /&gt;&lt;br /&gt;The scope of the Nix package manager, however, is limited to &lt;b&gt;package deployment&lt;/b&gt; only. Other tools in the Nix project extend deployment to other kinds of domains, such as machine level deployment (&lt;a href=&quot;https://sandervanderburg.blogspot.com/2011/01/nixos-purely-functional-linux.html&quot;&gt;NixOS&lt;/a&gt;), networks of machines (&lt;a href=&quot;https://sandervanderburg.blogspot.com/2015/03/on-nixops-disnix-service-deployment-and.html&quot;&gt;NixOps&lt;/a&gt;) and service-oriented systems (&lt;a href=&quot;https://sandervanderburg.blogspot.com/2011/02/disnix-toolset-for-distributed.html&quot;&gt;Disnix&lt;/a&gt;).&lt;br /&gt;&lt;br /&gt;In addition to packages, there is also a category of systems (such as systems following the microservices paradigm) that are composed of &lt;b&gt;running processes&lt;/b&gt;.&lt;br /&gt;&lt;br /&gt;Recently, I have been automating deployments of several kinds of systems that are composed of running processes and I have investigated how we can map the most common Nix packaging conventions to construct specifications that we can use to automate the deployment of these kinds of systems.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Some common Nix packaging conventions&lt;/h2&gt;&lt;br /&gt;The Nix package manager implements a so-called &lt;b&gt;purely functional deployment model&lt;/b&gt;. In Nix, packages are constructed in the Nix expression language from &lt;b&gt;pure functions&lt;/b&gt; in which side effects are eliminated as much as possible, such as undeclared dependencies residing in global directories, such as &lt;i&gt;/lib&lt;/i&gt; and &lt;i&gt;/bin&lt;/i&gt;.&lt;br /&gt;&lt;br /&gt;The function parameters of a build function refer to &lt;b&gt;all required inputs&lt;/b&gt; to construct the package, such as the build instructions, the source code, environment variables and all required build-time dependencies, such as compilers, build tools and libraries.&lt;br /&gt;&lt;br /&gt;A big advantage of eliminating side effects (or more realistically: significantly reducing side effects) is to support &lt;b&gt;reproducible deployment&lt;/b&gt; -- when building the same package with the same inputs on a different machine, we should get a (nearly) bit-identical result.&lt;br /&gt;&lt;br /&gt;Strong reproducibility guarantees, for example, make it possible to &lt;b&gt;optimize&lt;/b&gt; package deployments by only building a package from source code once and then downloading binary substitutes from remote servers that can be trusted.&lt;br /&gt;&lt;br /&gt;In addition to the fact that packages are constructed by executing pure functions (with some caveats), the Nixpkgs repository -- that contains a large set of well known free and open source packages -- follows a number of &lt;b&gt;conventions&lt;/b&gt;. One of such conventions is that most package build recipes reside in separate files and that each recipe declares a function.&lt;br /&gt;&lt;br /&gt;An example of such a build recipe is:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;font-size: 90%; overflow: auto;&quot;&gt;{ stdenv, fetchurl, pkgconfig, glib, gpm, file, e2fsprogs&lt;br /&gt;, perl, zip, unzip, gettext, libssh2, openssl}:&lt;br /&gt;&lt;br /&gt;stdenv.mkDerivation rec {&lt;br /&gt;  pname = &quot;mc&quot;;&lt;br /&gt;  version = &quot;4.8.23&quot;;&lt;br /&gt;&lt;br /&gt;  src = fetchurl {&lt;br /&gt;    url = &quot;http://www.midnight-commander.org/downloads/${pname}-${version}.tar.xz&quot;;&lt;br /&gt;    sha256 = &quot;077z7phzq3m1sxyz7li77lyzv4rjmmh3wp2vy86pnc4387kpqzyx&quot;;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  buildInputs = [&lt;br /&gt;    pkgconfig perl glib slang zip unzip file gettext libssh2 openssl&lt;br /&gt;  ];&lt;br /&gt;&lt;br /&gt;  configureFlags = [ &quot;--enable-vfs-smb&quot; ];&lt;br /&gt;&lt;br /&gt;  meta = {&lt;br /&gt;    description = &quot;File Manager and User Shell for the GNU Project&quot;;&lt;br /&gt;    homepage = http://www.midnight-commander.org;&lt;br /&gt;    maintainers = [ stdenv.lib.maintainers.sander ];&lt;br /&gt;    platforms = with stdenv.lib.platforms; linux ++ darwin;&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The Nix expression shown above (&lt;i&gt;pkgs/tools/misc/mc/default.nix&lt;/i&gt;) describes how to build the &lt;a href=&quot;http://www.midnight-commander.org/&quot;&gt;Midnight Commander&lt;/a&gt; from source code and its inputs:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;The first line declares a function in which the function arguments refer to all &lt;b&gt;dependencies&lt;/b&gt; required to build Midnight Commander: &lt;i&gt;stdenv&lt;/i&gt; refers to an environment that provides standard UNIX utilities, such as &lt;i&gt;cat&lt;/i&gt; and &lt;i&gt;ls&lt;/i&gt; and basic build utilities, such as &lt;i&gt;gcc&lt;/i&gt; and &lt;i&gt;make&lt;/i&gt;. &lt;i&gt;fetchurl&lt;/i&gt; is a utility function that can be used to download artifacts from remote locations and that can verify the integrity of the downloaded artifact.&lt;br /&gt;&lt;br /&gt;The remainder of the function arguments refer to packages that need to be provided as build-time dependencies, such as tools and libraries.&lt;/li&gt;&lt;li&gt;In the function body, we invoke the &lt;i&gt;stdenv.mkDerivation&lt;/i&gt; function to construct a Nix package from source code.&lt;br /&gt;&lt;br /&gt;By default, if no build instructions are provided, it will automatically execute the standard GNU Autotools/GNU Make build procedure: &lt;i&gt;./configure; make; make install&lt;/i&gt;, automatically downloads and unpacks the tarball specified by the &lt;i&gt;src&lt;/i&gt; parameter, and uses &lt;i&gt;buildInputs&lt;/i&gt; to instruct the configure script to automatically find the dependencies it needs.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;A function definition that describes a package build recipe is not very useful on its own -- to be able to build a package, it needs to be invoked with the appropriate parameters.&lt;br /&gt;&lt;br /&gt;A Nix package is &lt;b&gt;composed&lt;/b&gt; in a top-level Nix expression (&lt;i&gt;pkgs/top-level/all-packages.nix&lt;/i&gt;) that declares one big data structure: an attribute set, in which every attribute name refers to a possible variant of a package (typically only one) and each value to a function invocation that builds the package, with the desired versions of variants of the dependencies that a package may need:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;{ system ? builtins.currentSystem }:&lt;br /&gt;&lt;br /&gt;rec {&lt;br /&gt;  stdenv = ...&lt;br /&gt;  fetchurl = ...&lt;br /&gt;  pkgconfig = ...&lt;br /&gt;  glib = ...&lt;br /&gt;&lt;br /&gt;  ...&lt;br /&gt;&lt;br /&gt;  openssl = import ../development/libraries/openssl {&lt;br /&gt;    inherit stdenv fetchurl zlib ...;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  mc = import ../tools/misc/mc {&lt;br /&gt;    inherit stdenv fetchurl pkgconfig glib gpm file e2fsprogs perl;&lt;br /&gt;    inherit zip unzip gettext libssh2 openssl;&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The last attribute (&lt;i&gt;mc&lt;/i&gt;) in the attribute set shown above, builds a specific variant of Midnight Commander, by passing the dependencies that it needs as parameters. It uses the &lt;i&gt;inherit&lt;/i&gt; language construct to bind the parameters that are declared in the same lexical scope.&lt;br /&gt;&lt;br /&gt;All the dependencies that Midnight Commander needs are declared in the same attribute set and composed in a similar way.&lt;br /&gt;&lt;br /&gt;(As a sidenote: in the above example, we explicitly propagate all function parameters, which is quite verbose and tedious. In Nixpkgs, it is also possible to use a convenience function called: &lt;i&gt;callPackage&lt;/i&gt; that will automatically pass the attributes with the same names as the function arguments as parameters.)&lt;br /&gt;&lt;br /&gt;With the composition expression above and running the following command-line instruction:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;$ nix-build all-packages.nix -A mc&lt;br /&gt;/nix/store/wp3r8qv4k510...-mc-4.8.23&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The Nix package manager will first deploy all build-time dependencies that Midnight Commander needs, and will then build Midnight Commander from source code. The build result is stored in the &lt;b&gt;Nix store&lt;/b&gt; (&lt;i&gt;/nix/store/...-mc-4.8.23&lt;/i&gt;), in which all build artifacts reside in isolation in their own directories.&lt;br /&gt;&lt;br /&gt;We can start Midnight Commander by providing the full path to the &lt;i&gt;mc&lt;/i&gt; executable:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;$ /nix/store/wp3r8qv4k510...-mc-4.8.23/bin/mc&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The prefix of every artifact in the Nix store is a SHA256 hash code derived from all inputs provided to the build function. The SHA256 hash prefix makes it possible to safely store multiple versions and variants of the same package next to each other, because they never share the same name.&lt;br /&gt;&lt;br /&gt;If Nix happens to compute a SHA256 that is already in the Nix store, then the build result is exactly the same, preventing Nix from doing the same build again.&lt;br /&gt;&lt;br /&gt;Because the Midnight Commander build recipe is a function, we can also adjust the function parameters to build different variants of the same package. For example, by changing the &lt;i&gt;openssl&lt;/i&gt; parameter, we can build a Midnight Commander variant that uses a specific version of OpenSSL that is different than the default version:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;font-size: 90%; overflow: auto;&quot;&gt;{ system ? builtins.currentSystem }:&lt;br /&gt;&lt;br /&gt;rec {&lt;br /&gt;  stdenv = ...&lt;br /&gt;  fetchurl = ...&lt;br /&gt;  pkgconfig = ...&lt;br /&gt;  glib = ...&lt;br /&gt;&lt;br /&gt;  ...&lt;br /&gt;&lt;br /&gt;  openssl_1_1_0 = import ../development/libraries/openssl/1.1.0.nix {&lt;br /&gt;    inherit stdenv fetchurl zlib ...;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  mc_alternative = import ../tools/misc/mc {&lt;br /&gt;    inherit stdenv fetchurl pkgconfig glib gpm file e2fsprogs perl;&lt;br /&gt;    inherit zip unzip gettext libssh2;&lt;br /&gt;    openssl = openssl_1_1_0; # Use a different OpenSSL version&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;We can build our alternative Midnight Commander variant as follows:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;$ nix-build all-packages.nix -A mc_alternative&lt;br /&gt;/nix/store/0g0wm23y85nc0y...-mc-4.8.23&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;As may be noticed, we get a different Nix store path, because we build Midnight Commander with different build inputs.&lt;br /&gt;&lt;br /&gt;Although the purely functional model provides all kinds of nice benefits (such as reproducibility, the ability conveniently construct multiple variants of a package, and storing them in isolation without any conflicts), it also has a big inconvenience from a user point of view -- as a user, it is very impractical to remember the SHA256 hash prefixes of a package to start a program.&lt;br /&gt;&lt;br /&gt;As a solution, Nix also makes it possible to construct &lt;a href=&quot;https://sandervanderburg.blogspot.com/2013/09/managing-user-environments-with-nix.html&quot;&gt;&lt;b&gt;user environments&lt;/b&gt;&lt;/a&gt; (probably better known as Nix profiles), by using the &lt;i&gt;nix-env&lt;/i&gt; tool or using the &lt;i&gt;buildEnv {}&lt;/i&gt; function in Nixpkgs.&lt;br /&gt;&lt;br /&gt;User environments are symlink trees that blend the content of a set of packages into a single directory in the Nix store so that they can be accessed from one single location. By adding the &lt;i&gt;bin/&lt;/i&gt; sub folder of a user environment to the &lt;i&gt;PATH&lt;/i&gt; environment variable, it becomes possible for a user to start a command-line executable without specifying a full path.&lt;br /&gt;&lt;br /&gt;For example, with the &lt;i&gt;nix-env&lt;/i&gt; tool we can install the Midnight Commander in a Nix profile:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;$ nix-env -f all-packages.nix -iA mc&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;and then start it as follows:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;$ mc&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above command works if the Nix profile is in the &lt;i&gt;PATH&lt;/i&gt; environment variable of the user.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Mapping packaging conventions to process management&lt;/h2&gt;&lt;br /&gt;There are four important packaging conventions that the Nix package manager and the Nixpkgs repository follow that I want to emphasize:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Invoking the &lt;b&gt;derivation&lt;/b&gt; function (typically through &lt;i&gt;stdenv.mkDerivation&lt;/i&gt; or an abstraction built around it) builds a package from its build inputs.&lt;/li&gt;&lt;li&gt;Every package build recipe &lt;b&gt;defines&lt;/b&gt; a &lt;b&gt;function&lt;/b&gt; in which the function parameters refer to all possible build inputs. We can use this function to compose all kinds of variants of a package.&lt;/li&gt;&lt;li&gt;&lt;b&gt;Invoking&lt;/b&gt; a package build recipe function constructs a particular variant of a package and stores the result in the Nix store.&lt;/li&gt;&lt;li&gt;&lt;b&gt;Nix profiles&lt;/b&gt; blend the content of a collection of packages into one directory and makes them accessible from a single location.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;(As a sidenote: There is some discussion in the Nix community about these concepts. For example, one of the (self-)criticisms is that the Nix expression language, that is specifically designed as a DSL for package management, has no package concept in the language.&lt;br /&gt;&lt;br /&gt;Despite this oddity, I personally think that functions are a simple and powerful concept. The only thing that is a bit of a poor decision in my opinion is to call the mechanism that executes a build: &lt;b&gt;derivation&lt;/b&gt;).&lt;br /&gt;&lt;br /&gt;Process management is quite different from package management -- we need to have an executable deployed first (typically done by a package manager, such as Nix), but in addition, we also need to &lt;b&gt;manage&lt;/b&gt; the &lt;b&gt;life-cycle&lt;/b&gt; of a process, such as starting and stopping it. These facilities are not Nix's responsibility. Instead, we need to work with a &lt;b&gt;process manager&lt;/b&gt; that can facilitate these.&lt;br /&gt;&lt;br /&gt;Furthermore, systems composed of running processes have a kind of dependency relationship that Nix does not manage -- they may also communicate with other processes (e.g. via a network connection or UNIX domain sockets).&lt;br /&gt;&lt;br /&gt;As a consequence, they require the presence of other processes in order to work. This means that processes need to be activated in the right order or, alternatively, the communication between two dependent processes need to be queued until both are available.&lt;br /&gt;&lt;br /&gt;If these dependency requirements are not met, then a system may not work. For example, a web application process is useless if the database backend is not available.&lt;br /&gt;&lt;br /&gt;In order to fully automate the deployment of systems that are composed of running processes, we can do package management with Nix first and then we need to:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;Integrate with a process manager&lt;/b&gt;, by generating artifacts that a process manager can work with, such as scripts and/or configuration files.&lt;/li&gt;&lt;li&gt;Make it possible to specify the &lt;b&gt;process dependencies&lt;/b&gt; so that they can be managed (by a process manager or by other means) and activated in the right order.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;h2&gt;Generating sysvinit scripts&lt;/h2&gt;&lt;br /&gt;There a variety of means to manage processes. A simple (and for today's standards maybe an old fashioned and perhaps controversial) way to manage processes is by using &lt;a href=&quot;https://wiki.archlinux.org/index.php/SysVinit&quot;&gt;sysvinit scripts&lt;/a&gt; (also known as LSB Init compliant scripts).&lt;br /&gt;&lt;br /&gt;A sysvinit script implements a set of activities and a standardized interface allowing us to manage the lifecycle of a specific process, or a group of processes.&lt;br /&gt;&lt;br /&gt;For example, on a traditional Linux distribution, we can start a process, such as the &lt;a href=&quot;https://nginx.com&quot;&gt;Nginx web server&lt;/a&gt;, with the following command:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;$ /etc/init.d/nginx start&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;and stop it as follows: &lt;br /&gt;&lt;br /&gt;&lt;pre&gt;$ /etc/init.d/nginx stop&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;A sysvinit script is straight forward to implement and follows a number of conventions:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto;&quot;&gt;#!/bin/bash&lt;br /&gt;&lt;br /&gt;## BEGIN INIT INFO&lt;br /&gt;# Provides:      nginx&lt;br /&gt;# Default-Start: 3 4 5&lt;br /&gt;# Default-Stop:  0 1 2 6&lt;br /&gt;# Should-Start:  webapp&lt;br /&gt;# Should-Stop:   webapp&lt;br /&gt;# Description:   Nginx&lt;br /&gt;## END INIT INFO&lt;br /&gt;&lt;br /&gt;. /lib/lsb/init-functions&lt;br /&gt;&lt;br /&gt;case &quot;$1&quot; in&lt;br /&gt;  start)&lt;br /&gt;    log_info_msg &quot;Starting Nginx...&quot;&lt;br /&gt;    mkdir -p /var/nginx/logs&lt;br /&gt;    start_daemon /usr/bin/nginx -c /etc/nginx.conf -p /var/nginx &lt;br /&gt;    evaluate_retval&lt;br /&gt;    ;;&lt;br /&gt;&lt;br /&gt;  stop)&lt;br /&gt;    log_info_msg &quot;Stopping Nginx...&quot;&lt;br /&gt;    killproc /usr/bin/nginx&lt;br /&gt;    evaluate_retval&lt;br /&gt;    ;;&lt;br /&gt;&lt;br /&gt;  reload)&lt;br /&gt;    log_info_msg &quot;Reloading Nginx...&quot;&lt;br /&gt;    killproc /usr/bin/nginx -HUP&lt;br /&gt;    evaluate_retval&lt;br /&gt;    ;;&lt;br /&gt;&lt;br /&gt;  restart)&lt;br /&gt;    $0 stop&lt;br /&gt;    sleep 1&lt;br /&gt;    $0 start&lt;br /&gt;    ;;&lt;br /&gt;&lt;br /&gt;  status)&lt;br /&gt;    statusproc /usr/bin/nginx&lt;br /&gt;    ;;&lt;br /&gt;&lt;br /&gt;  *)&lt;br /&gt;    echo &quot;Usage: $0 {start|stop|reload|restart|status}&quot;&lt;br /&gt;    exit 1&lt;br /&gt;    ;;&lt;br /&gt;esac&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;A sysvinit script typically starts by providing some &lt;b&gt;metadata&lt;/b&gt;, such a description, in which runlevels it needs to be started and stopped, and which dependencies the script has.&lt;br /&gt;&lt;br /&gt;In classic Linux distributions, meta information is typically ignored, but more sophisticated process managers, such as &lt;a href=&quot;https://www.freedesktop.org/wiki/Software/systemd/&quot;&gt;systemd&lt;/a&gt;, can use it to automatically configure the activation/deactivation ordering.&lt;/li&gt;&lt;li&gt;The body defines a &lt;b&gt;case statement&lt;/b&gt; that executes a requested activity.&lt;/li&gt;&lt;li&gt;Activities use a special construct (in the example above it is: &lt;i&gt;evaluate_retval&lt;/i&gt;) to display the &lt;b&gt;status&lt;/b&gt; of an instruction, typically whether a process has started or stopped successfully or not, using appropriate colors (e.g. red in case of a failure, green in case of sucess).&lt;/li&gt;&lt;li&gt;sysvinit scripts typically define a number of &lt;b&gt;commonly used activities&lt;/b&gt;: &lt;i&gt;start&lt;/i&gt; starts a process, &lt;i&gt;stop&lt;/i&gt; stops a process, &lt;i&gt;reload&lt;/i&gt; sends a &lt;i&gt;HUP&lt;/i&gt; signal to the process to let it reload its configuration (if applicable), &lt;i&gt;restart&lt;/i&gt; restarts the process, &lt;i&gt;status&lt;/i&gt; indicates the status, and there is a fallback activity that displays the usage to the end user to show which activities can be executed.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;sysvinit scripts use number of utility functions that are defined by the &lt;a href=&quot;http://refspecs.linuxbase.org/lsb.shtml&quot;&gt;Linux Standards Base (LSB)&lt;/a&gt;:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;&lt;i&gt;start_daemon&lt;/i&gt; is a utility function that is typically used for starting a process. It has the expectation that the process &lt;a href=&quot;http://www.netzmafia.de/skripten/unix/linux-daemon-howto.html&quot;&gt;daemonizes&lt;/a&gt; -- a process that daemonizes will fork another process that keeps running in the background and then terminates immediately.&lt;br /&gt;&lt;br /&gt;Controlling a daemonized processes is a bit tricky -- when spawning a process the shell can tell you its process id (PID), so that it can be controlled, but it cannot tell you the PID of the process that gets daemonized by the invoked process, because that is beyond the shell's control.&lt;br /&gt;&lt;br /&gt;As a solution, most programs that daemonize will write a PID file (e.g. &lt;i&gt;/var/run/nginx.pid&lt;/i&gt;) that can be used to determine the PID of the daemon so that it can be controlled.&lt;br /&gt;&lt;br /&gt;To do proper housekeeping, the &lt;i&gt;start_daemon&lt;/i&gt; function will check whether such a PID file already exists, and will only start the process when it needs to.&lt;/li&gt;&lt;li&gt;Stopping a process, or sending it a different kind of signal, is typically done with the &lt;i&gt;killproc&lt;/i&gt; function.&lt;br /&gt;&lt;br /&gt;This function will search for the corresponding PID file of the process (by default, a PID file that has the same name as the executable or a specified PID file) and uses the corresponding PID content to terminate the daemon. As a fallback, if no PID file exists, it will scan the entire process table and kills the process with the same name.&lt;/li&gt;&lt;li&gt;We can determine the status of a process (e.g. whether it is running or not), with the &lt;i&gt;statusproc&lt;/i&gt; function that also consults the corresponding PID file or scans the process table if needed.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;Most common system software have the ability to deamonize, such as nginx, the Apache HTTP server, MySQL and PostgreSQL. Unfortunately, application services (such as microservices) that are implemented with technologies such as Python, Node.js or Java Springboot do not have this ability out of the box.&lt;br /&gt;&lt;br /&gt;Fortunately, we can use an external utility, such as &lt;a href=&quot;http://www.libslack.org/daemon/&quot;&gt;libslack's daemon command&lt;/a&gt;, to let these foreground-only processes daemonize. Although it is possible to conveniently daemonize external processes, this functionality is not part of the LSB standard.&lt;br /&gt;&lt;br /&gt;For example, using the following command to start the web application front-end process will automatically daemonize a foreground process, such as a simple Node.js web application, and creates a PID file so that it can be controlled by the sysvinit utility functions:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;$ daemon -U -i /home/sander/webapp/app.js&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;In addition to manually starting and stopping sysvinit scripts, sysvinit scripts are also typically started on startup and stopped on shutdown, or when a user switches between runlevels. These processes are controlled by symlinks that reside in an &lt;i&gt;rc.d&lt;/i&gt; directory that have specific prefixes:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;/etc/&lt;br /&gt;  init.d/&lt;br /&gt;    webapp&lt;br /&gt;    nginx&lt;br /&gt;  rc0.d/&lt;br /&gt;    K98nginx -&amp;gt; ../init.d/nginx&lt;br /&gt;    K99webapp -&amp;gt; ../init.d/webapp&lt;br /&gt;  rc1.d/&lt;br /&gt;    K98nginx -&amp;gt; ../init.d/nginx&lt;br /&gt;    K99webapp -&amp;gt; ../init.d/webapp&lt;br /&gt;  rc2.d/&lt;br /&gt;    K98nginx -&amp;gt; ../init.d/nginx&lt;br /&gt;    K99webapp -&amp;gt; ../init.d/webapp&lt;br /&gt;  rc3.d/&lt;br /&gt;    S00webapp -&amp;gt; ../init.d/nginx&lt;br /&gt;    S01nginx -&amp;gt; ../init.d/webapp&lt;br /&gt;  rc4.d/&lt;br /&gt;    S00webapp -&amp;gt; ../init.d/nginx&lt;br /&gt;    S01nginx -&amp;gt; ../init.d/webapp&lt;br /&gt;  rc5.d/&lt;br /&gt;    S00webapp -&amp;gt; ../init.d/nginx&lt;br /&gt;    S01nginx -&amp;gt; ../init.d/webapp&lt;br /&gt;  rc6.d/&lt;br /&gt;    K98nginx -&amp;gt; ../init.d/nginx&lt;br /&gt;    K99webapp -&amp;gt; ../init.d/webapp&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;In the above directory listing, every &lt;i&gt;rc?.d&lt;/i&gt; directory contains symlinks to scripts in the &lt;i&gt;init.d&lt;/i&gt; directory.&lt;br /&gt;&lt;br /&gt;The first character of each symlink file indicates whether an &lt;i&gt;init.d&lt;/i&gt; script should be started (S) or stopped (K). The two numeric digits that follow indicate the order in which the scripts need to be started and stopped.&lt;br /&gt;&lt;br /&gt;Each runlevel has a specific purpose &lt;a href=&quot;https://refspecs.linuxbase.org/LSB_3.0.0/LSB-PDA/LSB-PDA/runlevels.html&quot;&gt;as described in the LSB standard&lt;/a&gt;. In the above situation, when we boot the system in multi-user mode on the console (run level 3), first our Node.js web application will be started, followed by nginx. On a reboot (when we enter runlevel 6) nginx and then the web application will be stopped. Basically, the stop order is the reverse of the start order.&lt;br /&gt;&lt;br /&gt;To conveniently automate the deployment of sysvinit scripts, I have created a utility function called: &lt;i&gt;createSystemVInitScript&lt;/i&gt; that makes it possible to generate sysvinit script with the Nix package manager.&lt;br /&gt;&lt;br /&gt;We can create a Nix expression that generates a sysvinit script for nginx, such as:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;{createSystemVInitScript, nginx}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  configFile = ./nginx.conf;&lt;br /&gt;  stateDir = &quot;/var&quot;;&lt;br /&gt;in&lt;br /&gt;createSystemVInitScript {                                                                                                                                                                                          &lt;br /&gt;  name = &quot;nginx&quot;;&lt;br /&gt;  description = &quot;Nginx&quot;;&lt;br /&gt;  activities = {&lt;br /&gt;    start = ''&lt;br /&gt;      mkdir -p ${stateDir}/logs&lt;br /&gt;      log_info_msg &quot;Starting Nginx...&quot;&lt;br /&gt;      loadproc ${nginx}/bin/nginx -c ${configFile} -p ${stateDir}&lt;br /&gt;      evaluate_retval&lt;br /&gt;    '';&lt;br /&gt;    stop = ''&lt;br /&gt;      log_info_msg &quot;Stopping Nginx...&quot;&lt;br /&gt;      killproc ${nginx}/bin/nginx&lt;br /&gt;      evaluate_retval&lt;br /&gt;    '';&lt;br /&gt;    reload = ''&lt;br /&gt;      log_info_msg &quot;Reloading Nginx...&quot;&lt;br /&gt;      killproc ${nginx}/bin/nginx -HUP&lt;br /&gt;      evaluate_retval&lt;br /&gt;    '';&lt;br /&gt;    restart = ''&lt;br /&gt;      $0 stop&lt;br /&gt;      sleep 1&lt;br /&gt;      $0 start&lt;br /&gt;    '';&lt;br /&gt;    status = &quot;statusproc ${nginx}/bin/nginx&quot;;&lt;br /&gt;  };&lt;br /&gt;  runlevels = [ 3 4 5 ];&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above expression defines a function in which the function parameters refer to all dependencies that we need to construct the sysvinit script to manage a nginx server: &lt;i&gt;createSystemVInitScript&lt;/i&gt; is the utility function that creates sysvinit scripts, &lt;i&gt;nginx&lt;/i&gt; is the package that provides Nginx.&lt;br /&gt;&lt;br /&gt;In the body, we invoke the: &lt;i&gt;createSystemVInitScript&lt;/i&gt; to construct a sysvinit script:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;The &lt;b&gt;name&lt;/b&gt; corresponds to name of the sysvinit script and the &lt;b&gt;description&lt;/b&gt; to the description displayed in the metadata header.&lt;/li&gt;&lt;li&gt;The &lt;b&gt;activities&lt;/b&gt; parameter refers to an attribute set in which every name refers to an activity and every value to the shell commands that need to be executed for this activity.&lt;br /&gt;&lt;br /&gt;We can use this parameter to specify the start, stop, reload, restart and status activities for nginx. The function abstraction will automatically configure the fallback activity that displays the usage to the end-user including the activities that the script supports.&lt;/li&gt;&lt;li&gt;The &lt;b&gt;runlevels&lt;/b&gt; parameter indicates in which runlevels the &lt;i&gt;init.d&lt;/i&gt; script should be started. For these runlevels, the function will create start symlinks. An implication is that for the runlevels that are not specified (0, 1, 2, and 6) the script will automatically create stop symlinks.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;As explained earlier, sysvinit script use conventions. One of such conventions is that most activities typically display a description, then execute a command, and finally display the status of that command, such as:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;log_info_msg &quot;Starting Nginx...&quot;&lt;br /&gt;loadproc ${nginx}/bin/nginx -c ${configFile} -p ${stateDir}&lt;br /&gt;evaluate_retval&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The &lt;i&gt;createSystemVInit&lt;/i&gt; script also a notion of &lt;b&gt;instructions&lt;/b&gt;, that are automatically translated into activities displaying task descriptions (derived from the general description) and the status. Using the &lt;i&gt;instructions&lt;/i&gt; parameter allows us to simplify the above expression to:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;{createSystemVInitScript, nginx}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  configFile = ./nginx.conf;&lt;br /&gt;  stateDir = &quot;/var&quot;;&lt;br /&gt;in&lt;br /&gt;createSystemVInitScript {                                                                                                                                                                                          &lt;br /&gt;  name = &quot;nginx&quot;;&lt;br /&gt;  description = &quot;Nginx&quot;;&lt;br /&gt;  instructions = {&lt;br /&gt;    start = {&lt;br /&gt;      activity = &quot;Starting&quot;;&lt;br /&gt;      instruction = ''&lt;br /&gt;        mkdir -p ${stateDir}/logs&lt;br /&gt;        loadproc ${nginx}/bin/nginx -c ${configFile} -p ${stateDir}&lt;br /&gt;      '';&lt;br /&gt;    };&lt;br /&gt;    stop = {&lt;br /&gt;      activity = &quot;Stopping&quot;;&lt;br /&gt;      instruction = &quot;killproc ${nginx}/bin/nginx&quot;;&lt;br /&gt;    };&lt;br /&gt;    reload = {&lt;br /&gt;      activity = &quot;Reloading&quot;;&lt;br /&gt;      instruction = &quot;killproc ${nginx}/bin/nginx -HUP&quot;;&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;  activities = {&lt;br /&gt;    status = &quot;statusproc ${nginx}/bin/nginx&quot;;&lt;br /&gt;  };&lt;br /&gt;  runlevels = [ 3 4 5 ];&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;In the above expression, the start, stop and reload activities have been simplified by defining them as instructions allowing us to write less repetitive boilerplate code.&lt;br /&gt;&lt;br /&gt;We can reduce the amount of boilerplate code even further -- the kind of activities that we need to implement for managing process are typically mostly the same. When we want to manage a process, we typically want a start, stop, restart, status activity and, if applicable, a reload activity if a process knows how to handle the HUP signal.&lt;br /&gt;&lt;br /&gt;Instead of speciying activities or instructions, it is also possible to specify which process we want to manage, and what kind of parameters the process should take:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;{createSystemVInitScript, nginx}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  configFile = ./nginx.conf;&lt;br /&gt;  stateDir = &quot;/var&quot;;&lt;br /&gt;in&lt;br /&gt;createSystemVInitScript {                                                                                                                                                                                          &lt;br /&gt;  name = &quot;nginx&quot;;&lt;br /&gt;  description = &quot;Nginx&quot;;&lt;br /&gt;  initialize = ''&lt;br /&gt;    mkdir -p ${stateDir}/logs&lt;br /&gt;  '';&lt;br /&gt;  process = &quot;${nginx}/bin/nginx&quot;;&lt;br /&gt;  args = [ &quot;-c&quot; configFile &quot;-p&quot; stateDir ];&lt;br /&gt;  runlevels = [ 3 4 5 ];&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;From the &lt;i&gt;process&lt;/i&gt; and &lt;i&gt;args&lt;/i&gt; parameters, the &lt;i&gt;createSystemVInitScript&lt;/i&gt; automatically derives all relevant activities that we need to manage the process. It is also still possible to augment or override the generated activities by means of the &lt;i&gt;instructions&lt;/i&gt; or &lt;i&gt;activities&lt;/i&gt; parameters.&lt;br /&gt;&lt;br /&gt;Besides processes that already have the ability to daemonize, it is also possible to automatically daemonize foreground processes with this function abstraction. This is particularly useful to generate a sysvinit script for the Node.js web application service, that lacks this ability:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;{createSystemVInitScript}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  webapp = (import ./webapp {}).package;&lt;br /&gt;in&lt;br /&gt;createSystemVInitScript {&lt;br /&gt;  name = &quot;webapp&quot;;&lt;br /&gt;  process = &quot;${webapp}/lib/node_modules/webapp/app.js&quot;;&lt;br /&gt;  processIsDaemon = false;&lt;br /&gt;  runlevels = [ 3 4 5 ];&lt;br /&gt;  environment = {&lt;br /&gt;    PORT = 5000;&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;In the above Nix expression, we set the parameter: &lt;i&gt;processIsDaemon&lt;/i&gt; to &lt;i&gt;false&lt;/i&gt; (the default value is: &lt;i&gt;true&lt;/i&gt;) to indicate that the process is not a deamon, but a foreground process. The &lt;i&gt;createSystemVInitScript&lt;/i&gt; function will generate a start activity that invokes the &lt;i&gt;daemon&lt;/i&gt; command to daemonize it.&lt;br /&gt;&lt;br /&gt;Another interesting feature is that we can specify &lt;strong&gt;process dependency relationships&lt;/strong&gt;. For example, an nginx server can act as a reverse proxy for the Node.js web application.&lt;br /&gt;&lt;br /&gt;To reliably activate the entire system, we must make sure that the web application process is deployed before Nginx is deployed. If we activate the system in the opposite order, then the reverse proxy may redirect users to an non-existent web application causing them to see 502 bad gateway errors.&lt;br /&gt;&lt;br /&gt;We can use the &lt;strong&gt;dependency parameter&lt;/strong&gt; with a reference to a sysvinit script to indicate that this sysvinit script has a dependency. For example, we can revise the Nginx sysvinit script expression as follows:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;{createSystemVInitScript, nginx, webapp}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  configFile = ./nginx.conf;&lt;br /&gt;  stateDir = &quot;/var&quot;;&lt;br /&gt;in&lt;br /&gt;createSystemVInitScript {                                                                                                                                                                                          &lt;br /&gt;  name = &quot;nginx&quot;;&lt;br /&gt;  description = &quot;Nginx&quot;;&lt;br /&gt;  initialize = ''&lt;br /&gt;    mkdir -p ${stateDir}/logs&lt;br /&gt;  '';&lt;br /&gt;  process = &quot;${nginx}/bin/nginx&quot;;&lt;br /&gt;  args = [ &quot;-c&quot; configFile &quot;-p&quot; stateDir ];&lt;br /&gt;  runlevels = [ 3 4 5 ];&lt;br /&gt;  dependencies = [ webapp ];&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;In the above example, we pass the &lt;i&gt;webapp&lt;/i&gt; sysvinit script as a dependency (through the &lt;i&gt;dependencies&lt;/i&gt; parameter). Adding it as a dependency causes the generator to compute a start sequence number for the nginx script that will be higher than the web app sysvinit script and stop sequence number that will be lower than the web app script.&lt;br /&gt;&lt;br /&gt;The different sequence numbers ensure that webapp is started before nginx starts, and that the nginx stops before the webapp stops.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Configuring managed processes&lt;/h2&gt;&lt;br /&gt;So far composing sysvinit scripts is still very similar to composing ordinary Nix packages. We can also extend the four Nix packaging conventions described in the introduction to create a process management discipline.&lt;br /&gt;&lt;br /&gt;Similar to the convention in which every package is in a separate file, and defines a function in which the function parameters refers to all package dependencies, we can extend this convention for processes to also include relevant parameters to configure a service.&lt;br /&gt;&lt;br /&gt;For example, we can write a Nix expression for the web application process as follows:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;{createSystemVInitScript, port ? 5000}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  webapp = (import /home/sander/webapp {}).package;&lt;br /&gt;in&lt;br /&gt;createSystemVInitScript {&lt;br /&gt;  name = &quot;webapp&quot;;&lt;br /&gt;  process = &quot;${webapp}/lib/node_modules/webapp/app.js&quot;;&lt;br /&gt;  processIsDaemon = false;&lt;br /&gt;  runlevels = [ 3 4 5 ];&lt;br /&gt;  environment = {&lt;br /&gt;    PORT = port;&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;In the above expression, the &lt;i&gt;port&lt;/i&gt; function parameter allows us to configure the TCP port where the web application listens to (and defaults to 5000).&lt;br /&gt;&lt;br /&gt;We can also make the configuration of nginx configurable. For example, we can create a function abstraction that creates a configuration for nginx to let it act as a reverse proxy for the web application process shown earlier:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;{createSystemVInitScript, stdenv, writeTextFile, nginx&lt;br /&gt;, runtimeDir, stateDir, logDir, port ? 80, webapps ? []}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  nginxStateDir = &quot;${stateDir}/nginx&quot;;&lt;br /&gt;in&lt;br /&gt;import ./nginx.nix {&lt;br /&gt;  inherit createSystemVInitScript nginx instanceSuffix;&lt;br /&gt;  stateDir = nginxStateDir;&lt;br /&gt;&lt;br /&gt;  dependencies = map (webapp: webapp.pkg) webapps;&lt;br /&gt;&lt;br /&gt;  configFile = writeTextFile {&lt;br /&gt;    name = &quot;nginx.conf&quot;;&lt;br /&gt;    text = ''&lt;br /&gt;      error_log ${nginxStateDir}/logs/error.log;&lt;br /&gt;      pid ${runtimeDir}/nginx.pid;&lt;br /&gt;&lt;br /&gt;      events {&lt;br /&gt;        worker_connections 190000;&lt;br /&gt;      }&lt;br /&gt;&lt;br /&gt;      http {&lt;br /&gt;        ${stdenv.lib.concatMapStrings (dependency: ''&lt;br /&gt;          upstream webapp${toString dependency.port} {&lt;br /&gt;            server localhost:${toString dependency.port};&lt;br /&gt;          }&lt;br /&gt;        '') webapps}&lt;br /&gt;&lt;br /&gt;        ${stdenv.lib.concatMapStrings (dependency: ''&lt;br /&gt;          server {&lt;br /&gt;            listen ${toString port};&lt;br /&gt;            server_name ${dependency.dnsName};&lt;br /&gt;&lt;br /&gt;            location / {&lt;br /&gt;              proxy_pass  http://webapp${toString dependency.port};&lt;br /&gt;            }&lt;br /&gt;          }&lt;br /&gt;        '') webapps}&lt;br /&gt;      }&lt;br /&gt;    '';&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above Nix expression's funtion header defines, in addition to the package dependencies, process configuration parameters that make it possible to configure the TCP port that Nginx listens to (port 80 by default) and to which web applications it should forward requests based on their virtual host property.&lt;br /&gt;&lt;br /&gt;In the body, these properties are used to generate a &lt;i&gt;nginx.conf&lt;/i&gt; file that defines virtualhosts for each web application process. It forwards incoming requests to the appropriate web application instance. To connect to a web application instance, it uses the port number that the &lt;i&gt;webapp&lt;/i&gt; instance configuration provides.&lt;br /&gt;&lt;br /&gt;Similar to ordinary Nix expressions, Nix expressions for processes also need to be composed, by passing the appropriate function parameters. This can be done in a &lt;strong&gt;process composition expression&lt;/strong&gt; that has the following structure:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;{ pkgs ? import &amp;lt;nixpkgs&amp;gt; { inherit system; }&lt;br /&gt;, system ? builtins.currentSystem&lt;br /&gt;, stateDir ? &quot;/var&quot;&lt;br /&gt;, runtimeDir ? &quot;${stateDir}/run&quot;&lt;br /&gt;, logDir ? &quot;${stateDir}/log&quot;&lt;br /&gt;, tmpDir ? (if stateDir == &quot;/var&quot; then &quot;/tmp&quot; else &quot;${stateDir}/tmp&quot;)&lt;br /&gt;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  createSystemVInitScript = import ./create-sysvinit-script.nix {&lt;br /&gt;    inherit (pkgs) stdenv writeTextFile daemon;&lt;br /&gt;    inherit runtimeDir tmpDir;&lt;br /&gt;&lt;br /&gt;    createCredentials = import ./create-credentials.nix {&lt;br /&gt;      inherit (pkgs) stdenv;&lt;br /&gt;    };&lt;br /&gt;&lt;br /&gt;    initFunctions = import ./init-functions.nix {&lt;br /&gt;      basePackages = [&lt;br /&gt;        pkgs.coreutils&lt;br /&gt;        pkgs.gnused&lt;br /&gt;        pkgs.inetutils&lt;br /&gt;        pkgs.gnugrep&lt;br /&gt;        pkgs.sysvinit&lt;br /&gt;      ];&lt;br /&gt;      inherit (pkgs) stdenv;&lt;br /&gt;      inherit runtimeDir;&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;in&lt;br /&gt;rec {&lt;br /&gt;  webapp = rec {&lt;br /&gt;    port = 5000;&lt;br /&gt;    dnsName = &quot;webapp.local&quot;;&lt;br /&gt;&lt;br /&gt;    pkg = import ./webapp.nix {&lt;br /&gt;      inherit createSystemVInitScript port;&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  nginxReverseProxy = rec {&lt;br /&gt;    port = 80;&lt;br /&gt;&lt;br /&gt;    pkg = import ./nginx-reverse-proxy.nix {&lt;br /&gt;      inherit createSystemVInitScript;&lt;br /&gt;      inherit stateDir logDir runtimeDir port;&lt;br /&gt;      inherit (pkgs) stdenv writeTextFile nginx;&lt;br /&gt;      webapps = [ webapp ];&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above expression (&lt;i&gt;processes.nix&lt;/i&gt;) has the following structure:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;The expression defines a function in which the function parameters allow common properties that apply to all processes to be configured: &lt;i&gt;pkgs&lt;/i&gt; refers to the set of Nixpkgs that contains a big collection of free and open source packages, &lt;i&gt;system&lt;/i&gt; refers to the system architecture to build packages for, and &lt;i&gt;stateDir&lt;/i&gt; to the directory where processes should store their state (which is &lt;i&gt;/var&lt;/i&gt; according to the LSB standard).&lt;br /&gt;&lt;br /&gt;The remaining parameters specify the runtime, log and temp directories, that are typically sub directories in the state directory.&lt;/li&gt;&lt;li&gt;In the let block, we compose our &lt;i&gt;createSystemVInitScript&lt;/i&gt; function using the relevant state directory parameters, base packages and utility functions.&lt;/li&gt;&lt;li&gt;In the body, we construct an attribute set in which every name represents a process name and every value an attribute set that contains process properties.&lt;/li&gt;&lt;li&gt;One reserved process property of a process attribute set is the &lt;i&gt;pkg&lt;/i&gt; property that refers to a package providing the sysvinit script.&lt;/li&gt;&lt;li&gt;The remaining process properties can be freely chosen and can be consumed by any process that has a dependency on it.&lt;br /&gt;&lt;br /&gt;For example, the &lt;i&gt;nginxReverseProxy&lt;/i&gt; service uses the &lt;i&gt;port&lt;/i&gt; and &lt;i&gt;dnsName&lt;/i&gt; properties of the &lt;i&gt;webapp&lt;/i&gt; process to configure nginx to forward requests to the provided DNS host name (&lt;i&gt;webapp.local&lt;/i&gt;) to the web application process listening on the specified TCP port (&lt;i&gt;5000&lt;/i&gt;).&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;Using the above composition Nix expression for processes and the following command-line instruction, we can build the sysvinit script for the web application process:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;$ nix-build processes.nix -A webapp&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;We can start the web application process by using the generated sysvinit script, as follows:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;$ ./result/bin/etc/rc.d/init.d/webapp start&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;and stop it as follows:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;$ ./result/bin/etc/rc.d/init.d/webapp stop&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;We can also build the nginx reverse proxy in a similar way, but to properly activate it, we must make sure that the webapp process is activated first.&lt;br /&gt;&lt;br /&gt;To reliably manage a set of processes and activate them in the right order, we can also generate a Nix profile that contains all &lt;i&gt;init.d&lt;/i&gt; scripts and &lt;i&gt;rc.d&lt;/i&gt; symlinks for stopping and starting:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;{ pkgs ? import &amp;lt;nixpkgs&amp;gt; { inherit system; }&lt;br /&gt;, system ? builtins.currentSystem&lt;br /&gt;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  buildSystemVInitEnv = import ./build-sysvinit-env.nix {&lt;br /&gt;    inherit (pkgs) buildEnv;&lt;br /&gt;  };&lt;br /&gt;in&lt;br /&gt;buildSystemVInitEnv {&lt;br /&gt;  processes = import ./processes.nix {&lt;br /&gt;    inherit pkgs system;&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above expression imports the process composition expression shown earlier, and invokes the &lt;i&gt;buildSystemVInitEnv&lt;/i&gt; to compose a Nix profile out of it. We can build this environment as follows:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;$ nix-build profile.nix&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;Visually, the content of the Nix profile can presented as follows:&lt;br /&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-901SfouMyio/XcPyvcgwzcI/AAAAAAAAIgI/A6Er10Z55goGXuaDAG5lN4mY-nvXDX-XgCLcBGAsYHQ/s1600/processes-simple.png&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;https://1.bp.blogspot.com/-901SfouMyio/XcPyvcgwzcI/AAAAAAAAIgI/A6Er10Z55goGXuaDAG5lN4mY-nvXDX-XgCLcBGAsYHQ/s1600/processes-simple.png&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;In the above diagram the ovals denote processes and the arrows denote process dependency relationships. The arrow indicates that the &lt;i&gt;webapp&lt;/i&gt; process needs to be activated before the &lt;i&gt;nginxReverseProxy&lt;/i&gt;.&lt;br /&gt;&lt;br /&gt;We can use the system's &lt;i&gt;rc&lt;/i&gt; script manage the starting and stopping the processes when runlevels are switched. Runlevels 1-5 make it possible to start the processes on startup and 0 and 6 to stop them on shutdown or reboot.&lt;br /&gt;&lt;br /&gt;In addition to the system's &lt;i&gt;rc&lt;/i&gt; script, we can also directly control the processes in a Nix profile -- I have created a utility script called: &lt;i&gt;rcswitch&lt;/i&gt; that makes it possible to manually start all processes in a profile:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;$ rcswitch ./result/etc/rc.d/rc3.d&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;we can also use the &lt;i&gt;rcswitch&lt;/i&gt; command to do an upgrade from one set of processes to another:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;$ rcswitch ./result/etc/rc.d/rc.3 ./oldresult/etc/rc.d/rc3.d&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above command checks which of the sysvinit scripts exist in both profiles and will only deactivate obsolete processes and activate new processes.&lt;br /&gt;&lt;br /&gt;With the &lt;i&gt;rcrunactivity&lt;/i&gt; command it is possible to run arbitrary activities on all processes in a profile. For example, the following command will show all statuses:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;$ rcactivity status ./result/etc/rc.d/rc3.d&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;h2&gt;Deploying services as an unprivileged user&lt;/h2&gt;&lt;br /&gt;The process composition expression shown earlier is also a Nix function that takes various kinds of state properties as parameters.&lt;br /&gt;&lt;br /&gt;By default, it has been configured in such a way that it facilitates production deployments. For example, it stores the state of all services in the global &lt;i&gt;/var&lt;/i&gt; directory. Only the super user has the permissions to alter the structure of the global &lt;i&gt;/var&lt;/i&gt; directory.&lt;br /&gt;&lt;br /&gt;It is also possible to change these configuration parameters in such a way that it becomes possible as an unprivileged user to do process deployment.&lt;br /&gt;&lt;br /&gt;For example, by changing the port number of the &lt;i&gt;nginxReverseProxy&lt;/i&gt; process to a value higher than 1024, such as 8080 (an unprivileged user is not allowed to bind any services to ports below 1024), and changing the &lt;i&gt;stateDir&lt;/i&gt; parameter to a directory in a user's home directory, we can deploy our web application service and Nginx reverse proxy as an unprivileged user:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;$ nix-build processes.nix --argstr stateDir /home/sander/var \&lt;br /&gt;  -A nginxReverseProxy&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;By overriding the &lt;i&gt;stateDir&lt;/i&gt; parameter, the resulting Nginx process has been configured to store all state in &lt;i&gt;/home/sander/var&lt;/i&gt; as opposed to the global &lt;i&gt;/var&lt;/i&gt; that cannot be modified by an unprivileged user.&lt;br /&gt;&lt;br /&gt;As an unprivileged user, I should be able to start the Nginx reverse proxy as follows:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;$ ./result/etc/rc.d/init.d/nginx start&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above Nginx instance can be reached by opening: &lt;i&gt;http://localhost:8080&lt;/i&gt; in a web browser.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Creating multiple process instances&lt;/h2&gt;&lt;br /&gt;So far, we have only been deploying single instances of processes. For the Nginx reverse proxy example, it may also be desired to deploy &lt;strong&gt;multiple instances&lt;/strong&gt; of the webapp process so that we can manage forwardings for multiple virtual domains.&lt;br /&gt;&lt;br /&gt;We can adjust the Nix expression for the webapp to make it possible to create multiple process instances:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;{createSystemVInitScript}:&lt;br /&gt;{port, instanceSuffix ? &quot;&quot;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  webapp = (import ./webapp {}).package;&lt;br /&gt;  instanceName = &quot;webapp${instanceSuffix}&quot;;&lt;br /&gt;in&lt;br /&gt;createSystemVInitScript {&lt;br /&gt;  name = instanceName;&lt;br /&gt;  inherit instanceName;&lt;br /&gt;  process = &quot;${webapp}/lib/node_modules/webapp/app.js&quot;;&lt;br /&gt;  processIsDaemon = false;&lt;br /&gt;  runlevels = [ 3 4 5 ];&lt;br /&gt;  environment = {&lt;br /&gt;    PORT = port;&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above Nix expression is a modified webapp build recipe that facilitates instantiation:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;We have split the Nix expression into two nested functions. The first line: the outer function header defines all dependencies and configurable properties that apply to all services instances.&lt;/li&gt;&lt;li&gt;The inner function header allows all &lt;b&gt;instance specific&lt;/b&gt; properties to be configured so that multiple instances can co-exist. An example of such a property is the &lt;i&gt;port&lt;/i&gt; parameter -- only one service can bind to a specific TCP port. Configuring an instance to bind to different port allows two instances co-exist.&lt;br /&gt;&lt;br /&gt;The &lt;i&gt;instanceSuffix&lt;/i&gt; parameter makes it possible to give each webapp process a unique name (e.g. by providing a numeric value).&lt;br /&gt;&lt;br /&gt;From the package name and instance suffix a unique &lt;i&gt;instanceName&lt;/i&gt; is composed. Propagating the &lt;i&gt;instanceName&lt;/i&gt; to the &lt;i&gt;createSystemVInitScript&lt;/i&gt; function instructs the &lt;i&gt;daemon&lt;/i&gt; command to create a unique PID file (not a PID file that corresponds to the executable name) for each daemon process so that multiple instances can be controlled independently.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;Although this may sound as a very uncommon use case, it is also possible to change the Nix expression for the Nginx reverse proxy to support multiple instances.&lt;br /&gt;&lt;br /&gt;Typically, for system services, such as web servers and database servers, it is very uncommon to run multiple instances at the same time. Despite the fact that it is uncommon, it is actually possible and quite useful for development and/or experimentation purposes:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;{ createSystemVInitScript, stdenv, writeTextFile, nginx&lt;br /&gt;, runtimeDir, stateDir, logDir}:&lt;br /&gt;&lt;br /&gt;{port ? 80, webapps ? [], instanceSuffix ? &quot;&quot;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  instanceName = &quot;nginx${instanceSuffix}&quot;;&lt;br /&gt;  nginxStateDir = &quot;${stateDir}/${instanceName}&quot;;&lt;br /&gt;in&lt;br /&gt;import ./nginx.nix {&lt;br /&gt;  inherit createSystemVInitScript nginx instanceSuffix;&lt;br /&gt;  stateDir = nginxStateDir;&lt;br /&gt;&lt;br /&gt;  dependencies = map (webapp: webapp.pkg) webapps;&lt;br /&gt;&lt;br /&gt;  configFile = writeTextFile {&lt;br /&gt;    name = &quot;nginx.conf&quot;;&lt;br /&gt;    text = ''&lt;br /&gt;      error_log ${nginxStateDir}/logs/error.log;&lt;br /&gt;      pid ${runtimeDir}/${instanceName}.pid;&lt;br /&gt;&lt;br /&gt;      events {&lt;br /&gt;        worker_connections 190000;&lt;br /&gt;      }&lt;br /&gt;&lt;br /&gt;      http {&lt;br /&gt;        ${stdenv.lib.concatMapStrings (dependency: ''&lt;br /&gt;          upstream webapp${toString dependency.port} {&lt;br /&gt;            server localhost:${toString dependency.port};&lt;br /&gt;          }&lt;br /&gt;        '') webapps}&lt;br /&gt;&lt;br /&gt;        ${stdenv.lib.concatMapStrings (dependency: ''&lt;br /&gt;          server {&lt;br /&gt;            listen ${toString port};&lt;br /&gt;            server_name ${dependency.dnsName};&lt;br /&gt;&lt;br /&gt;            location / {&lt;br /&gt;              proxy_pass  http://webapp${toString dependency.port};&lt;br /&gt;            }&lt;br /&gt;          }&lt;br /&gt;        '') webapps}&lt;br /&gt;      }&lt;br /&gt;    '';&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The code fragment above shows a revised Nginx expression that supports instantiation:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Again, the Nix expression defines a nested function in which the outer function header refers to configuration properties for all services, whereas the inner function header refers to all conflicting parameters that need to be changed so that multiple instances can co-exist.&lt;/li&gt;&lt;li&gt;The &lt;i&gt;port&lt;/i&gt; parameter allows the TCP port where Nginx bind to be configured. To have two instances co-existing they both need to bind to unreserved ports.&lt;/li&gt;&lt;li&gt;As with the previous example, the &lt;i&gt;instanceSuffix&lt;/i&gt; parameter makes it possible to compose unique names for each Nginx instance. The &lt;i&gt;instanceName&lt;/i&gt; variable that is composed from it, is used to create and configure a dedicate state directory, and a unique PID file that does not conflict with other Nginx instances.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;With this new convention of nested functions for instantiatable services means that we have to compose these expressions twice. First, we need to pass all parameters that configure properties that apply to all service instances. This can be done in a Nix expression that has the following structure:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;{ pkgs&lt;br /&gt;, system&lt;br /&gt;, stateDir&lt;br /&gt;, logDir&lt;br /&gt;, runtimeDir&lt;br /&gt;, tmpDir&lt;br /&gt;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  createSystemVInitScript = import ./create-sysvinit-script.nix {&lt;br /&gt;    inherit (pkgs) stdenv writeTextFile daemon;&lt;br /&gt;    inherit runtimeDir tmpDir;&lt;br /&gt;&lt;br /&gt;    createCredentials = import ./create-credentials.nix {&lt;br /&gt;      inherit (pkgs) stdenv;&lt;br /&gt;    };&lt;br /&gt;&lt;br /&gt;    initFunctions = import ./init-functions.nix {&lt;br /&gt;      basePackages = [&lt;br /&gt;        pkgs.coreutils&lt;br /&gt;        pkgs.gnused&lt;br /&gt;        pkgs.inetutils&lt;br /&gt;        pkgs.gnugrep&lt;br /&gt;        pkgs.sysvinit&lt;br /&gt;      ];&lt;br /&gt;      inherit (pkgs) stdenv;&lt;br /&gt;      inherit runtimeDir;&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;in&lt;br /&gt;{&lt;br /&gt;  webapp = import ./webapp.nix {&lt;br /&gt;    inherit createSystemVInitScript;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  nginxReverseProxy = import ./nginx-reverse-proxy.nix {&lt;br /&gt;    inherit createSystemVInitScript stateDir logDir runtimeDir;&lt;br /&gt;    inherit (pkgs) stdenv writeTextFile nginx;&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above Nix expression is something we could call a &lt;b&gt;constructors expression&lt;/b&gt; (&lt;i&gt;constructors.nix&lt;/i&gt;) that returns an attribute set in which each member refers to a function that allows us to compose a specific process instance.&lt;br /&gt;&lt;br /&gt;By using the constructors expression shown above, we can create a processes composition expression that works with multiple instances:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;{ pkgs ? import  { inherit system; }&lt;br /&gt;, system ? builtins.currentSystem&lt;br /&gt;, stateDir ? &quot;/home/sbu&quot;&lt;br /&gt;, runtimeDir ? &quot;${stateDir}/run&quot;&lt;br /&gt;, logDir ? &quot;${stateDir}/log&quot;&lt;br /&gt;, tmpDir ? (if stateDir == &quot;/var&quot; then &quot;/tmp&quot; else &quot;${stateDir}/tmp&quot;)&lt;br /&gt;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  constructors = import ./constructors.nix {&lt;br /&gt;    inherit pkgs system stateDir runtimeDir logDir tmpDir;&lt;br /&gt;  };&lt;br /&gt;in&lt;br /&gt;rec {&lt;br /&gt;  webapp1 = rec {&lt;br /&gt;    port = 5000;&lt;br /&gt;    dnsName = &quot;webapp1.local&quot;;&lt;br /&gt;&lt;br /&gt;    pkg = constructors.webapp {&lt;br /&gt;      inherit port;&lt;br /&gt;      instanceSuffix = &quot;1&quot;;&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  webapp2 = rec {&lt;br /&gt;    port = 5001;&lt;br /&gt;    dnsName = &quot;webapp2.local&quot;;&lt;br /&gt;&lt;br /&gt;    pkg = constructors.webapp {&lt;br /&gt;      inherit port;&lt;br /&gt;      instanceSuffix = &quot;2&quot;;&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  webapp3 = rec {&lt;br /&gt;    port = 5002;&lt;br /&gt;    dnsName = &quot;webapp3.local&quot;;&lt;br /&gt;&lt;br /&gt;    pkg = constructors.webapp {&lt;br /&gt;      inherit port;&lt;br /&gt;      instanceSuffix = &quot;3&quot;;&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  webapp4 = rec {&lt;br /&gt;    port = 5003;&lt;br /&gt;    dnsName = &quot;webapp4.local&quot;;&lt;br /&gt;&lt;br /&gt;    pkg = constructors.webapp {&lt;br /&gt;      inherit port;&lt;br /&gt;      instanceSuffix = &quot;4&quot;;&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  nginxReverseProxy = rec {&lt;br /&gt;    port = 8080;&lt;br /&gt;&lt;br /&gt;    pkg = constructors.nginxReverseProxy {&lt;br /&gt;      webapps = [ webapp1 webapp2 webapp3 webapp4 ];&lt;br /&gt;      inherit port;&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  webapp5 = rec {&lt;br /&gt;    port = 6002;&lt;br /&gt;    dnsName = &quot;webapp5.local&quot;;&lt;br /&gt;&lt;br /&gt;    pkg = constructors.webapp {&lt;br /&gt;      inherit port;&lt;br /&gt;      instanceSuffix = &quot;5&quot;;&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  webapp6 = rec {&lt;br /&gt;    port = 6003;&lt;br /&gt;    dnsName = &quot;webapp6.local&quot;;&lt;br /&gt;&lt;br /&gt;    pkg = constructors.webapp {&lt;br /&gt;      inherit port;&lt;br /&gt;      instanceSuffix = &quot;6&quot;;&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  nginxReverseProxy2 = rec {&lt;br /&gt;    port = 8081;&lt;br /&gt;&lt;br /&gt;    pkg = constructors.nginxReverseProxy {&lt;br /&gt;      webapps = [ webapp5 webapp6 ];&lt;br /&gt;      inherit port;&lt;br /&gt;      instanceSuffix = &quot;2&quot;;&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;In the above expression, we import the constructors expression, as shown earlier. In the body, we construct multiple instances of these processes by using the constructors functions:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;We compose six web application instances (&lt;i&gt;webapp1&lt;/i&gt;, &lt;i&gt;webapp2&lt;/i&gt;, ..., &lt;i&gt;webapp6&lt;/i&gt;), each of them listening on a unique TCP port.&lt;/li&gt;&lt;li&gt;We compose two Nginx instances (&lt;i&gt;nginxReverseProxy&lt;/i&gt;, &lt;i&gt;nginxReverseProxy2&lt;/i&gt;). The first instance listens on TCP port 8080 and redirects the user to any of the first three web application processes, based on the virtual host name. The other Nginx instance listens on TCP port 8081, redirecting the user to the remaining web apps based on the virtual host name.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;We can represent the above composition expression visually, as follows:&lt;br /&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-syQ6BJILH0U/XcP1J5WDK6I/AAAAAAAAIgc/Ys2LMsIdGK0flM8sOL_lCGD9GP77GphpwCLcBGAsYHQ/s1600/processes-instances.png&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;https://1.bp.blogspot.com/-syQ6BJILH0U/XcP1J5WDK6I/AAAAAAAAIgc/Ys2LMsIdGK0flM8sOL_lCGD9GP77GphpwCLcBGAsYHQ/s400/processes-instances.png&quot; width=&quot;520&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;As with the previous examples, we can deploy each process instance individually:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;$ nix-build processes.nix -A webapp3&lt;br /&gt;$ ./result/etc/rc.d/init.d/webapp3 start&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;Or the the whole set as a Nix profile:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;$ nix-build profile.nix&lt;br /&gt;$ rcswitch ./result/etc/rc.d/rc3.d&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;Again, the &lt;i&gt;rcswitch&lt;/i&gt; command will make sure that all processes are activated in the right order. This means that the webapp processes are activated first, followed by the Nginx reverse proxies.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Managing user accounts/state with Dysnomia&lt;/h2&gt;&lt;br /&gt;Most of the deployment of the processes can be automated in a stateless way -- Nix can deploy the executable as a Nix package and the sysvinit script can manage the lifecycle.&lt;br /&gt;&lt;br /&gt;There is another concern, that we may also want to address. Typically, it is not recommended to run processes as a root user, such as essential system services, for security and safety reasons.&lt;br /&gt;&lt;br /&gt;In order to run a process as an unprivileged user, an unprivileged group and user account must be created first by some means. Furthermore, when undeploying a process, we may also want to remove the dedicated user and group.&lt;br /&gt;&lt;br /&gt;User account management is a feature that the Nix package manager does not support -- Nix only works with files stored in the Nix store and cannot/will not (by design) change any files on the host system, such as &lt;i&gt;/etc/passwd&lt;/i&gt; where the user accounts are stored.&lt;br /&gt;&lt;br /&gt;I have created a deployment tool for state management (&lt;a href=&quot;https://sandervanderburg.blogspot.com/2012/03/deployment-of-mutable-components.html&quot;&gt;Dysnomia&lt;/a&gt;) that can be used for this purpose. It facilitates a plugin system that can manage deployment activities for components that Nix does not support: activating, deactivating, taking snapshots, restoring snapshots etc.&lt;br /&gt;&lt;br /&gt;I have created a Dysnomia plugin called: &lt;i&gt;sysvinit-script&lt;/i&gt; that can activate or deactivate a process by invoking a sysvinit script. It can also create or discard users and groups from a declarative configuration file that is included with a sysvinit script.&lt;br /&gt;&lt;br /&gt;We can revise a process Nix expression to start a process as an unprivileged user:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;{createSystemVInitScript}:&lt;br /&gt;{port, instanceSuffix ? &quot;&quot;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  webapp = (import ./webapp {}).package;&lt;br /&gt;  instanceName = &quot;webapp${instanceSuffix}&quot;;&lt;br /&gt;in&lt;br /&gt;createSystemVInitScript {&lt;br /&gt;  name = instanceName;&lt;br /&gt;  inherit instanceName;&lt;br /&gt;  process = &quot;${webapp}/lib/node_modules/webapp/app.js&quot;;&lt;br /&gt;  processIsDaemon = false;&lt;br /&gt;  runlevels = [ 3 4 5 ];&lt;br /&gt;  environment = {&lt;br /&gt;    PORT = port;&lt;br /&gt;  };&lt;br /&gt;  user = instanceName;&lt;br /&gt;&lt;br /&gt;  credentials = {&lt;br /&gt;    groups = {&lt;br /&gt;      &quot;${instanceName}&quot; = {};&lt;br /&gt;    };&lt;br /&gt;    users = {&lt;br /&gt;      &quot;${instanceName}&quot; = {&lt;br /&gt;        group = instanceName;&lt;br /&gt;        description = &quot;Webapp&quot;;&lt;br /&gt;      };&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above Nix expression is a revised webapp Nix expression that facilitates user switching:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;The &lt;i&gt;user&lt;/i&gt; parameter specifies that we want to run the process as an unprivileged user. Because this process can also be instantiated, we have to make sure that it gets a unique name. To facilitate that, we create a user with the same username as the instance name.&lt;/li&gt;&lt;li&gt;The &lt;i&gt;credentials&lt;/i&gt; parameter refers to a specification that instructs the &lt;i&gt;sysvinit-script&lt;/i&gt; Dysnomia plugin to create an unprivileged user and group on activation, and discard them on deactivation.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;For production purposes (e.g. when we deploy processes as the root user), switching to unprivileged users is useful, but for development purposes, such as running a set of processes as an unprivileged user, we cannot switch users because we may not have the permissions to do so.&lt;br /&gt;&lt;br /&gt;For convenience purposes, it is also possible to globally disable user switching, which we can do as follows:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;{ pkgs&lt;br /&gt;, stateDir&lt;br /&gt;, logDir&lt;br /&gt;, runtimeDir&lt;br /&gt;, tmpDir&lt;br /&gt;, forceDisableUserChange&lt;br /&gt;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  createSystemVInitScript = import ./create-sysvinit-script.nix {&lt;br /&gt;    inherit (pkgs) stdenv writeTextFile daemon;&lt;br /&gt;    inherit runtimeDir tmpDir forceDisableUserChange;&lt;br /&gt;&lt;br /&gt;    createCredentials = import ./create-credentials.nix {&lt;br /&gt;      inherit (pkgs) stdenv;&lt;br /&gt;    };&lt;br /&gt;&lt;br /&gt;    initFunctions = import ./init-functions.nix {&lt;br /&gt;      basePackages = [&lt;br /&gt;        pkgs.coreutils&lt;br /&gt;        pkgs.gnused&lt;br /&gt;        pkgs.inetutils&lt;br /&gt;        pkgs.gnugrep&lt;br /&gt;        pkgs.sysvinit&lt;br /&gt;      ];&lt;br /&gt;      inherit (pkgs) stdenv;&lt;br /&gt;      inherit runtimeDir;&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;in&lt;br /&gt;{&lt;br /&gt;  ...&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;In the above example, the &lt;i&gt;forceDisableUserChange&lt;/i&gt; parameter can be used to globally disable user switching for all sysvinit scripts composed in the expression. It invokes a feature of the &lt;i&gt;createSystemVInitScript&lt;/i&gt; to ignore any user settings that might have been propagated to it.&lt;br /&gt;&lt;br /&gt;With the following command we can deploy a process that does not switch users, despite having user settings configured in the process Nix expressions:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;$ nix-build processes.nix --arg forceDisableUserChange true&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;h2&gt;Distributed process deployment with Disnix&lt;/h2&gt;&lt;br /&gt;As explained earlier, I have adopted four common Nix package conventions and extended them suit the needs of process management.&lt;br /&gt;&lt;br /&gt;This is not the only solution that I have implemented that builds on these four conventions -- the other solution is Disnix, that extends Nix's packaging principles to (distributed) service-oriented systems.&lt;br /&gt;&lt;br /&gt;Disnix extends Nix expressions for ordinary packages with another category of dependencies: &lt;b&gt;inter-dependencies&lt;/b&gt; that model dependencies on services that may have been deployed to remote machines in a network and require a network connection to work.&lt;br /&gt;&lt;br /&gt;In Disnix, a service expression is a nested function in which the outer function header specifies all &lt;b&gt;intra-dependencies&lt;/b&gt; (local dependencies, such as build tools and libraries), and the inner function header refers to inter-dependencies.&lt;br /&gt;&lt;br /&gt;It is also possible to combine the concepts of process deployment described in this blog post with the service-oriented system concepts of Disnix, such as inter-dependencies -- the example with Nginx reverse proxies and web application processes can be extended to work in a network of machines.&lt;br /&gt;&lt;br /&gt;Besides deploying a set processes (that may have dependencies on each other) to a single machine, it is also possible to deploy the web application processes to different machines in the network than the machine where the Nginx reverse proxy is deployed to.&lt;br /&gt;&lt;br /&gt;We can configure the reverse proxy in such a way that it will forward requests to the machine where the web application processes may have been deployed to.&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto;&quot;&gt;{ createSystemVInitScript, stdenv, writeTextFile, nginx&lt;br /&gt;, runtimeDir, stateDir, logDir&lt;br /&gt;}:&lt;br /&gt;&lt;br /&gt;{port ? 80, instanceSuffix ? &quot;&quot;}:&lt;br /&gt;&lt;br /&gt;interDeps:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  instanceName = &quot;nginx${instanceSuffix}&quot;;&lt;br /&gt;  nginxStateDir = &quot;${stateDir}/${instanceName}&quot;;&lt;br /&gt;in&lt;br /&gt;import ./nginx.nix {&lt;br /&gt;  inherit createSystemVInitScript nginx instanceSuffix;&lt;br /&gt;  stateDir = nginxStateDir;&lt;br /&gt;&lt;br /&gt;  dependencies = map (dependencyName: &lt;br /&gt;    let&lt;br /&gt;      dependency = builtins.getAttr dependencyName interDeps;&lt;br /&gt;    in&lt;br /&gt;    dependency.pkg&lt;br /&gt;   ) dependencies;&lt;br /&gt;&lt;br /&gt;  configFile = writeTextFile {&lt;br /&gt;    name = &quot;nginx.conf&quot;;&lt;br /&gt;    text = ''&lt;br /&gt;      error_log ${nginxStateDir}/logs/error.log;&lt;br /&gt;      pid ${runtimeDir}/${instanceName}.pid;&lt;br /&gt;&lt;br /&gt;      events {&lt;br /&gt;        worker_connections 190000;&lt;br /&gt;      }&lt;br /&gt;&lt;br /&gt;      http {&lt;br /&gt;        ${stdenv.lib.concatMapStrings (dependencyName:&lt;br /&gt;          let&lt;br /&gt;            dependency = builtins.getAttr dependencyName interDeps;&lt;br /&gt;          in&lt;br /&gt;          ''&lt;br /&gt;            upstream webapp${toString dependency.port} {&lt;br /&gt;              server ${dependency.target.properties.hostname}:${toString dependency.port};&lt;br /&gt;            }&lt;br /&gt;          '') (builtins.attrNames interDeps)}&lt;br /&gt;&lt;br /&gt;        ${stdenv.lib.concatMapStrings (dependencyName:&lt;br /&gt;          let&lt;br /&gt;            dependency = builtins.getAttr dependencyName interDeps;&lt;br /&gt;          in&lt;br /&gt;          ''&lt;br /&gt;            server {&lt;br /&gt;              listen ${toString port};&lt;br /&gt;              server_name ${dependency.dnsName};&lt;br /&gt;&lt;br /&gt;              location / {&lt;br /&gt;                proxy_pass  http://webapp${toString dependency.port};&lt;br /&gt;              }&lt;br /&gt;            }&lt;br /&gt;          '') (builtins.attrNames interDeps)}&lt;br /&gt;        }&lt;br /&gt;    '';&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above Nix expression is a revised Nginx configuration that also works with inter-dependencies:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;The above Nix expression defines three nested functions. The purpose of the outermost function (the first line) is to configure all local dependencies that are common to all process instances. The middle function defines all process instance parameters that are potentially conflicting and need to be configurd with unique values so that multiple instances can co-exist. The third (inner-most) function refers to the inter-dependencies of this process: services that may reside on a different machine in the network and need to be reached with a network connection.&lt;/li&gt;&lt;li&gt;The inter-dependency function header (&lt;i&gt;interDeps:&lt;/i&gt;) takes an arbitrary number of dependencies. These inter-dependencies refer to all web application process instances that the Nginx reverse proxy should redirect to.&lt;/li&gt;&lt;li&gt;In the body, we generate an &lt;i&gt;nginx.conf&lt;/i&gt; that uses the inter-dependencies to set up the forwardings.&lt;br /&gt;&lt;br /&gt;Compared to the previous Nginx reverse proxy example, it will use the &lt;i&gt;dependency.target.properties.hostname&lt;/i&gt; property that refers to the hostname of the machine where the web application process is deployed to instead of a forwarding to &lt;i&gt;localhost&lt;/i&gt;. This makes it possible to connect to a web application process that may have been deployed to another machine.&lt;/li&gt;&lt;li&gt;The inter-dependencies are also passed to the &lt;i&gt;dependencies&lt;/i&gt; function parameter of the Nginx function. This will ensure that if Nginx and a web application process are distributed to the same machine by Disnix, they will also get activated in the right order by the system's &lt;i&gt;rc&lt;/i&gt; script on startup.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;A with the previous examples, we need to compose the above Disnix expression multiple times. The composition of the constructors can be done in the constructors expression (as shown in the previous examples).&lt;br /&gt;&lt;br /&gt;The processes' instance properties and inter-dependencies can be configured in the Disnix &lt;b&gt;services model&lt;/b&gt;, that shares many similarities with process composition expression, shown earlier. As a matter of fact, a Disnix services model is a superset of it:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;{ pkgs, distribution, invDistribution, system&lt;br /&gt;, stateDir ? &quot;/var&quot;&lt;br /&gt;, runtimeDir ? &quot;${stateDir}/run&quot;&lt;br /&gt;, logDir ? &quot;${stateDir}/log&quot;&lt;br /&gt;, tmpDir ? (if stateDir == &quot;/var&quot; then &quot;/tmp&quot; else &quot;${stateDir}/tmp&quot;)&lt;br /&gt;, forceDisableUserChange ? true&lt;br /&gt;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  constructors = import ./constructors.nix {&lt;br /&gt;    inherit pkgs stateDir runtimeDir logDir tmpDir;&lt;br /&gt;    inherit forceDisableUserChange;&lt;br /&gt;  };&lt;br /&gt;in&lt;br /&gt;rec {&lt;br /&gt;  webapp = rec {&lt;br /&gt;    name = &quot;webapp&quot;;&lt;br /&gt;    port = 5000;&lt;br /&gt;    dnsName = &quot;webapp.local&quot;;&lt;br /&gt;    pkg = constructors.webapp {&lt;br /&gt;      inherit port;&lt;br /&gt;    };&lt;br /&gt;    type = &quot;sysvinit-script&quot;;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  nginxReverseProxy = rec {&lt;br /&gt;    name = &quot;nginxReverseProxy&quot;;&lt;br /&gt;    port = 8080;&lt;br /&gt;    pkg = constructors.nginxReverseProxy {&lt;br /&gt;      inherit port;&lt;br /&gt;    };&lt;br /&gt;    dependsOn = {&lt;br /&gt;      inherit webapp;&lt;br /&gt;    };&lt;br /&gt;    type = &quot;sysvinit-script&quot;;&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above Disnix services model defines two services (representing processes) that have an inter-dependency on each other, as specified with the &lt;i&gt;dependsOn&lt;/i&gt; parameter property of each service.&lt;br /&gt;&lt;br /&gt;The &lt;i&gt;sysvinit-script&lt;/i&gt; &lt;i&gt;type&lt;/i&gt; property instructs Disnix to deploy the services as processes managed by a sysvinit script. In a Disnix-context, services have no specific form or meaning, and can basically represent anything. The type property is used to tell Disnix with what kind of service we are dealing with.&lt;br /&gt;&lt;br /&gt;To properly configure remote dependencies we also need to know the target machines where we can deploy to and what their properties are. This is where we can use an &lt;b&gt;infrastructure&lt;/b&gt; model for.&lt;br /&gt;&lt;br /&gt;For example, a simple infrastructure model of two machines could be:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;{&lt;br /&gt;  test1.properties.hostname = &quot;test1&quot;;&lt;br /&gt;  test2.properties.hostname = &quot;test2&quot;;&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;We must also tell Disnix to which target machines we want to distribute the services. This can be done in a &lt;b&gt;distribution model&lt;/b&gt;:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;{infrastructure}:&lt;br /&gt;&lt;br /&gt;{&lt;br /&gt;  webapp = [ infrastructure.test1 ];&lt;br /&gt;  nginxReverseProxy = [ infrastructure.test2 ];&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;In the above distribution model we distribute the &lt;i&gt;webapp&lt;/i&gt; process to the first target machine and the &lt;i&gt;nginxReverseProxy&lt;/i&gt; to the second machine. Because both services are deployed to different machines in the network, the &lt;i&gt;nginxReverseProxy&lt;/i&gt; uses a network link to forward incoming requests to the web application.&lt;br /&gt;&lt;br /&gt;By running the following command-line instruction:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;font-size: 90%;&quot;&gt;$ disnix-env -s services.nix -i infrastructure.nix -d distribution.nix&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;Disnix will deploy the processes to the target machines defined in the distribution model.&lt;br /&gt;&lt;br /&gt;The result is the following deployment architecture:&lt;br /&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-s_AJzyNIr38/XcP1acRlEyI/AAAAAAAAIgk/PmVj4qDFQTwatjcMGuxevkYtXNQMEZtvwCLcBGAsYHQ/s1600/processes-distributed.png&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;https://1.bp.blogspot.com/-s_AJzyNIr38/XcP1acRlEyI/AAAAAAAAIgk/PmVj4qDFQTwatjcMGuxevkYtXNQMEZtvwCLcBGAsYHQ/s1600/processes-distributed.png&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;As may be noticed by looking at the above diagram, the process dependency manifest itself as a network link managed as an inter-dependency by Disnix.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Conclusion&lt;/h2&gt;&lt;br /&gt;In this blog post, I have described a Nix-based functional organization for managing processes based on four simple Nix packaging conventions. This approach offers the following benefits:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Integration with many process managers that manage the lifecycle of a process (in this particular blog post: using sysvinit scripts).&lt;/li&gt;&lt;li&gt;The ability to relocate state to other locations, which is useful to facilitate unprivileged user deployments.&lt;/li&gt;&lt;li&gt;The ability to create multiple instances of processes, by making conflicting properties configurable.&lt;/li&gt;&lt;li&gt;Disabling user switching, which is useful to facilitate unprivileged user deployments.&lt;/li&gt;&lt;li&gt;It can be used on any Linux system that has the Nix package manager installed. It can be used on NixOS, but NixOS is not a requirement.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;h3&gt;Related work&lt;/h3&gt;&lt;br /&gt;Integrating process management with Nix package deployment is not a new subject, nor something that is done for the first time.&lt;br /&gt;&lt;br /&gt;Many years ago, there was the &quot;trace&quot; Subversion repository (that was named after the research project TraCE: Transparent Configuration Environments funded by &lt;a href=&quot;http://www.jacquard.nl&quot;&gt;NWO/Jacquard&lt;/a&gt;), the repository in which all Nix-related development was done before the transition was made to GitHub (before 2012).&lt;br /&gt;&lt;br /&gt;In the trace repository, there was also a services project that could be used to generate sysvinit-like scripts that could be used on any Linux distribution, and several non-Linux systems as well, such as FreeBSD.&lt;br /&gt;&lt;br /&gt;Eelco Dolstra's PhD thesis Chapter 9 describes a distributed deployment prototype that extends the init script approach to networks of machines. The prototype facilitates the distribution of init scripts to remote machines and heterogeneous operating systems deployment -- an init script can be built for multiple operating systems, such as Linux and FreeBSD.&lt;br /&gt;&lt;br /&gt;Although the prototype shares some concepts with Disnix and the process management described in this blog post support, it also lacks many features -- it has no notion of process dependencies, inter-dependencies, the ability to separate services/processes and infrastructure, and to specify distribution mappings between process and target machines including the deployment of redundant instances.&lt;br /&gt; &amp;gt;&lt;br /&gt;Originally, NixOS used to work with the generated scripts from services sub project in the trace repository, but quite quickly adopted &lt;a href=&quot;http://upstart.ubuntu.com&quot;&gt;Upstart&lt;/a&gt; as its init system. Gradually, the init scripts and upstart jobs got integrated, and eventually replaced by Upstart jobs completely. As a result, it was no longer possible to run services independently of NixOS.&lt;br /&gt;&lt;br /&gt;NixOS is a Linux distribution whose static aspects are fully managed by Nix, including user packages, configuration files, the Linux kernel, and kernel modules. NixOS machine configurations are deployed from a single declarative specification.&lt;br /&gt;&lt;br /&gt;Although NixOS is an extension of Nix deployment principles to machine-level deployment, a major conceptual difference between NixOS and the Nix packages repository is that NixOS generates a big data structure made out of all potential configuration options that NixOS provides. It uses this (very big) generated data structure as an input for an activation script that will initialize all dynamic system parts, such as populating the state directories (e.g. &lt;i&gt;/var&lt;/i&gt;) and loading systemd jobs.&lt;br /&gt;&lt;br /&gt;In early incarnations of NixOS, the organization of the repository was quite monolithic -- there was one NixOS file that defines all configuration options for all possible system configuration aspetcts, one file that defines the all the system user accounts, one file that defines all global configuration files in &lt;i&gt;/etc&lt;/i&gt;. When it was desired to add a new system service, all these global configuration files need to be modified.&lt;br /&gt;&lt;br /&gt;Some time later (mid 2009), the NixOS module system was introduced that makes it possible to isolate all related configuration aspects of, for example, a system service into a separate module. Despite the fact that configuration aspects are isolated, the NixOS module system has the ability (through a concept called &lt;a href=&quot;http://r6.ca/blog/20140422T142911Z.html&quot;&gt;fixed points&lt;/a&gt;) to refer to properties of the entire configuration. The NixOS module system merges all configuration aspects of all modules into a single configuration data structure.&lt;br /&gt;&lt;br /&gt;The NixOS module system is quite powerful. In many ways, it is much more powerful than the process management approach described in this blog post. The NixOS module system allows you to refer, override and adjust any system configuration aspect in any module.&lt;br /&gt;&lt;br /&gt;For example, a system service, such as the OpenSSH server, can automatically configure the firewall module in such a way that it will open the SSH port (port 22). With the functional approach described in this blog post, everything has to be made explicit and must be propagated through function arguments. This is probably more memory efficient, but a lot less flexible, and more tedious to write.&lt;br /&gt;&lt;br /&gt;There are also certain things that NixOS and the NixOS module system cannot do. For example, with NixOS, it is not possible to create multiple instances of system services which the process management conventions described in this blog post can.&lt;br /&gt;&lt;br /&gt;NixOS has another drawback -- evaluating system configurations requires all possible NixOS configuration options to be evaluated. &lt;a href=&quot;https://nixos.org/nixos/manual/options.html&quot;&gt;There are actually quite a few of of them&lt;/a&gt;.&lt;br /&gt;&lt;br /&gt;As a result, evaluating a NixOS configuration is quite slow and memory consuming. For single systems, this is typically not a big problem, but for networked NixOS/NixOps configurations, this may be a problem -- for example, I have an old laptop with 4 GiB of RAM that can no longer deploy a test network of three VirtualBox machines using the latest stable NixOS release (19.09), because the Nix evaluator runs out of memory.&lt;br /&gt;&lt;br /&gt;Furthermore, NixOS system services can only be used when you install NixOS as your system's software distribution. It is currently not possible to install Nix on a conventional Linux distribution and use NixOS' system services (systemd services) independently of the entire operating system.&lt;br /&gt;&lt;br /&gt;The lack of being able to deploy system services independently is not a limitation of the NixOS module system -- there is also an external project called &lt;a href=&quot;https://github.com/LnL7/nix-darwin&quot;&gt;&lt;i&gt;nix-darwin&lt;/i&gt;&lt;/a&gt; that uses the NixOS module system to generate launchd services, that can be run on top of macOS, that is not managed by the Nix package manager.&lt;br /&gt;&lt;br /&gt;The idea to have a separate function header for creating instances of processes is also not entirely new -- a couple of years ago &lt;a href=&quot;https://sandervanderburg.blogspot.com/2016/06/deploying-containers-with-disnix-as.html&quot;&gt;I have revised the internal deployment model of Disnix to support multiple container instances&lt;/a&gt;.&lt;br /&gt;&lt;br /&gt;In a Disnix-context, containers can represent anything that can host multiple service instances, such as a process manager, application container, or database management system. I was already using the convention to have a separate function header that makes it possible to create multiple instances of services. In this blog post, I have extended this formalism specifically for managing processes.&lt;br /&gt;&lt;br /&gt;&lt;h3&gt;Discussion&lt;/h3&gt;&lt;br /&gt;In this blog post, I have picked sysvinit scripts for process management. The reason why I have picked an old-fashioned solution is not that I consider this to be the best process management facility, or that systemd, the init system that NixOS uses, is a bad solution.&lt;br /&gt;&lt;br /&gt;My first reason to choose sysvinit scripts is because it is more universally supported than systemd.&lt;br /&gt;&lt;br /&gt;The second reason is that I want to emphasize the value that a functional organization can provide, independent of the process management solution.&lt;br /&gt;&lt;br /&gt;Using sysvinit scripts for managing process have all kinds of drawbacks and IMO there is a legitimate reason why alternatives exist, such as systemd (but also other solutions).&lt;br /&gt;&lt;br /&gt;For example, controlling daemonized processes is difficult and fragile -- the convention that daemons should follow is to create PID files, but it is not a hard guarantee daemons will comply and that nothing will go wrong. As a result, a daemonized process may escape control of the process manager. systemd, for example, puts all processes that it needs to control in a cgroup and as a result, cannot escape systemd's control.&lt;br /&gt;&lt;br /&gt;Furthermore, you may also want to use the more advanced features of the Linux kernel, such as namespaces and cgroups to prevent process from interfering with other processes on the system and the available system resources that a system provides. Namespaces and cgroups are a first class feature in systemd.&lt;br /&gt;&lt;br /&gt;If you do not like sysvinit scripts: the functional organization described in this blog post is not specifically designed for sysvinit -- it is actually &lt;strong&gt;process manager agnostic&lt;/strong&gt;. I have also implemented a function called: &lt;i&gt;createSystemdService&lt;/i&gt; that makes it possible to construct systemd services.&lt;br /&gt;&lt;br /&gt; The following Nix expression composes a systemd service for the web application process, shown earlier:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;{stdenv, createSystemdService}:&lt;br /&gt;{port, instanceSuffix ? &quot;&quot;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  webapp = (import ./webapp {}).package;&lt;br /&gt;  instanceName = &quot;webapp${instanceSuffix}&quot;;&lt;br /&gt;in&lt;br /&gt;createSystemdService {&lt;br /&gt;  name = instanceName;&lt;br /&gt;&lt;br /&gt;  environment = {&lt;br /&gt;    PORT = port;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  Unit = {&lt;br /&gt;    Description = &quot;Example web application&quot;;&lt;br /&gt;    Documentation = http://example.com;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  Service = {&lt;br /&gt;    ExecStart = &quot;${webapp}/lib/node_modules/webapp/app.js&quot;;&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;I also tried &lt;a href=&quot;http://supervisord.org/&quot;&gt;supervisord&lt;/a&gt; -- we can write the following Nix expression to compose a supervisord program configuration file for the web application process:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;{stdenv, createSupervisordProgram}:&lt;br /&gt;{port, instanceSuffix ? &quot;&quot;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  webapp = (import ./webapp {}).package;&lt;br /&gt;  instanceName = &quot;webapp${instanceSuffix}&quot;;&lt;br /&gt;in&lt;br /&gt;createSupervisordProgram {&lt;br /&gt;  name = instanceName;&lt;br /&gt;&lt;br /&gt;  command = &quot;${webapp}/lib/node_modules/webapp/app.js&quot;;&lt;br /&gt;  environment = {&lt;br /&gt;    PORT = port;&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;Switching process managers retains our ability to benefit from the facilities that the functional configuration framework provides -- we can use it manage process dependencies, configure state directories, disable user management and when we use Disnix: manage inter-dependencies and bind it to services that are not processes.&lt;br /&gt;&lt;br /&gt;Despite the fact that sysvinit scripts are primitive, there are also two advantages that I see over more &quot;modern alternatives&quot;, such as systemd:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Systemd and supervisord require the presence of a deamon that manages processes (i.e. the systemd and supervisord deamons). sysvinit scripts are &lt;strong&gt;self-contained&lt;/strong&gt; from a process management perspective -- the Nix package manager provides the package dependencies that the sysvinit scripts needs (e.g. basic shell utilities, sysvinit commands), but other than that, it does not require anything else.&lt;/li&gt;&lt;li&gt;We can also easily deploy sysvinit scripts to any Linux distribution that has the Nix package manager installed. There are no additional requirements. Systemd services, for example, require the presence of the systemd daemon. Furthermore, we also have to interfere with the host system's systemd service that may also be used to manage essential system services.&lt;/li&gt;&lt;li&gt;We can also easily use sysvinit scripts to deploy processes as an unprivileged user to a machine that has a single-user Nix installation -- the sysvinit script infrastructure does not require any tools or daemons that require super user privileges.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;h2&gt;Acknowledgements&lt;/h2&gt;&lt;br /&gt;I have borrowed the &lt;i&gt;init-functions&lt;/i&gt; script from the LFS Bootscripts package of the &lt;a href=&quot;http://linuxfromscratch.org&quot;&gt;Linux from Scratch project&lt;/a&gt; to get an implementation of the utility functions that the LSB standard describes.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Availability and future work&lt;/h2&gt;&lt;br /&gt;The functionality described in this blog post is still a work in progress and only a first milestone in a bigger objective.&lt;br /&gt;&lt;br /&gt;The latest implementation of the process management framework can be found in &lt;a href=&quot;https://github.com/svanderburg/nix-processmgmt&quot;&gt;my experimental Nix process management repository&lt;/a&gt;. The &lt;i&gt;sysvinit-script&lt;/i&gt; Dysnomia plugin resides in &lt;a href=&quot;https://github.com/svanderburg/dysnomia/tree/processmanagement-wip&quot;&gt;an experimental branch of the Dysnomia repository&lt;/a&gt;.&lt;br /&gt;&lt;br /&gt;In the next blog post, I will introduce another interesting concept that we can integrate into the functional process management framework.&lt;br /&gt;&lt;br /&gt;</description>
	<pubDate>Mon, 11 Nov 2019 22:43:00 +0000</pubDate>
	<author>noreply@blogger.com (Sander van der Burg)</author>
</item>
<item>
	<title>Hercules Labs: Launching Hercules CI</title>
	<guid isPermaLink="true">https://blog.hercules-ci.com/2019/10/22/launching-hercules-ci/</guid>
	<link>https://blog.hercules-ci.com/2019/10/22/launching-hercules-ci/</link>
	<description>&lt;p&gt;In March 2018 we set ourselves a &lt;strong&gt;mission to provide seamless infrastructure to teams using Nix
in day-to-day software development&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;In June 2018 we &lt;a href=&quot;https://cachix.org/&quot;&gt;released a solution for developers to easily share binary caches&lt;/a&gt;,
trusted today by over a thousand developers.&lt;/p&gt;

&lt;p&gt;In Octobter 2018 we &lt;a href=&quot;https://www.youtube.com/watch?v=py26iM26Qg4&amp;amp;list=PLgknCdxP89ReJKWX3sthcsbBYsoihzSQX&amp;amp;index=12&amp;amp;t=137s&quot;&gt;showed the very first demo of Hercules CI at NixCon 2018&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In March 2019 we added &lt;a href=&quot;https://blog.hercules-ci.com/cachix/nix/2019/03/07/announcing-private-cachix/&quot;&gt;added support for private binary caches&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Since April 2019 we have been gradually giving out early access to the preview release with over &lt;strong&gt;a hundred participating developers&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&quot;today&quot;&gt;Today&lt;/h2&gt;

&lt;p&gt;We are &lt;strong&gt;announcing general availability of continuous integration specialized for Nix projects.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://hercules-ci.com&quot;&gt;Check out the landing page to get started&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;going-forward&quot;&gt;Going forward&lt;/h2&gt;

&lt;p&gt;In the coming months we’re going to work closely with customers to polish the experience and continue to save developer’s time.&lt;/p&gt;

&lt;p&gt;For &lt;strong&gt;support&lt;/strong&gt; (with getting started and other questions),
contact me at &lt;a href=&quot;mailto:domen@hercules-ci.com&quot;&gt;domen@hercules-ci.com&lt;/a&gt; so we can set you up
and make sure you get the most out of our CI.&lt;/p&gt;

&lt;p&gt;Subscribe to &lt;a href=&quot;https://twitter.com/hercules_ci&quot;&gt;@hercules_ci&lt;/a&gt; for updates.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;what-we-do&quot;&gt;What we do&lt;/h2&gt;

&lt;p&gt;Automated hosted infrastructure for Nix, reliable and reproducible developer tooling,
to speed up adoption and lower integration cost. We offer
&lt;a href=&quot;https://hercules-ci.com&quot;&gt;Continuous Integration&lt;/a&gt; and &lt;a href=&quot;https://cachix.org&quot;&gt;Binary Caches&lt;/a&gt;.&lt;/p&gt;</description>
	<pubDate>Tue, 22 Oct 2019 00:00:00 +0000</pubDate>
</item>
<item>
	<title>Matthew Bauer: Improved performance in Nixpkgs</title>
	<guid isPermaLink="true">https://matthewbauer.us/blog/avoid-subshells.html</guid>
	<link>https://matthewbauer.us/blog/avoid-subshells.html</link>
	<description>&lt;div class=&quot;outline-2&quot; id=&quot;outline-container-org9610d97&quot;&gt;
&lt;h2 id=&quot;org9610d97&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;1&lt;/span&gt; Avoiding subshells&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;
&lt;p&gt;
A common complain in using Nixpkgs is that things can become slow when
you have lots of dependencies. Processing of build inputs is processed
in Bash which tends to be pretty hard to make performant. Bash doesn’t
give us any way to loop through dependencies in parallel, so we end up
with pretty slow Bash. Luckily, someone has found some ways to speed
this up with some clever tricks in the &lt;code&gt;setup.sh&lt;/code&gt; script.
&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;outline-3&quot; id=&quot;outline-container-orgd7f8feb&quot;&gt;
&lt;h3 id=&quot;orgd7f8feb&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.1&lt;/span&gt; Pull request&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-1&quot;&gt;
&lt;p&gt;
Albert Safin (&lt;a href=&quot;https://github.com/xzfc&quot;&gt;@xzfc&lt;/a&gt; on GitHub) made an excellent PR that promises to
improve performance for all users of Nixpkgs. The PR is available at
&lt;a href=&quot;https://github.com/NixOS/nixpkgs/pull/69131&quot;&gt;PR #69131&lt;/a&gt;. The basic idea is to avoid invoking “subshells” in Bash. A
subshell is basically anything that uses &lt;code&gt;$(cmd ...)&lt;/code&gt;. Each subshell
requires forking a new process which has a constant time cost that
ends up being ~2ms. This isn’t much in isolation, but adds up in big
loops.
&lt;/p&gt;

&lt;p&gt;
Subshells are usually used in Bash because they are convenient and
easy to reason about. It’s easy to understand how a subshell works as
it’s just substituting the result of one command into another’s
arguments. We don’t usually care about the performance cost of
subshells. In the hot path of Nixpkgs’ &lt;code&gt;setup.sh&lt;/code&gt;, however, it’s
pretty important to squeeze every bit of performance we can.
&lt;/p&gt;

&lt;p&gt;
A few interesting changes were required to make this work. I’ll go
through and document what there are. More information can be found at
&lt;a href=&quot;https://www.gnu.org/software/bash/manual/bash.html&quot;&gt;the Bash manual&lt;/a&gt;.
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;
&lt;pre class=&quot;src src-diff&quot;&gt;&lt;span class=&quot;org-diff-context&quot;&gt;diff --git a/pkgs/stdenv/generic/setup.sh b/pkgs/stdenv/generic/setup.sh&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;index 326a60676a26..60067a4051de 100644&lt;/span&gt;
&lt;span class=&quot;org-diff-header&quot;&gt;--- &lt;/span&gt;&lt;span class=&quot;org-diff-header&quot;&gt;&lt;span class=&quot;org-diff-file-header&quot;&gt;a/pkgs/stdenv/generic/setup.sh&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;org-diff-header&quot;&gt;+++ &lt;/span&gt;&lt;span class=&quot;org-diff-header&quot;&gt;&lt;span class=&quot;org-diff-file-header&quot;&gt;b/pkgs/stdenv/generic/setup.sh&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;org-diff-hunk-header&quot;&gt;@@ -98,7 +98,7 @@&lt;/span&gt;&lt;span class=&quot;org-diff-function&quot;&gt; _callImplicitHook() {&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt; # hooks exits the hook, not the caller. Also will only pass args if&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt; # command can take them&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt; _eval() {&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-removed&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;org-diff-removed&quot;&gt;    if [ &quot;$(type -t &quot;$1&quot;)&quot; = function ]; then&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;    if declare -F &quot;$1&quot; &amp;gt; /dev/null 2&amp;gt;&amp;amp;1; then&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;         set +u&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;         &quot;$@&quot; # including args&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;     else&lt;/span&gt;

&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
The first change is pretty easy to understand. It just replaces the
&lt;code&gt;type&lt;/code&gt; call with a &lt;code&gt;declare&lt;/code&gt; call, utilizing an exit code in place of
stdout. Unfortunately, &lt;code&gt;declare&lt;/code&gt; is &lt;a href=&quot;https://www.gnu.org/software/bash/manual/bash.html#index-declare&quot;&gt;a Bashism&lt;/a&gt; which is not available
in all POSIX shells. It’s been ill defined whether Bashisms can be
used in Nixpkgs, but we now will require Nixpkgs to be sourced with
Bash 4+.
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;
&lt;pre class=&quot;src src-diff&quot;&gt;&lt;span class=&quot;org-diff-context&quot;&gt;diff --git a/pkgs/stdenv/generic/setup.sh b/pkgs/stdenv/generic/setup.sh&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;index 60067a4051de..7e7f8739845b 100644&lt;/span&gt;
&lt;span class=&quot;org-diff-header&quot;&gt;--- &lt;/span&gt;&lt;span class=&quot;org-diff-header&quot;&gt;&lt;span class=&quot;org-diff-file-header&quot;&gt;a/pkgs/stdenv/generic/setup.sh&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;org-diff-header&quot;&gt;+++ &lt;/span&gt;&lt;span class=&quot;org-diff-header&quot;&gt;&lt;span class=&quot;org-diff-file-header&quot;&gt;b/pkgs/stdenv/generic/setup.sh&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;org-diff-hunk-header&quot;&gt;@@ -403,6 +403,7 @@&lt;/span&gt;&lt;span class=&quot;org-diff-function&quot;&gt; findInputs() {&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;     # The current package's host and target offset together&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;     # provide a &amp;lt;=-preserving homomorphism from the relative&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;     # offsets to current offset&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;    local -i mapOffsetResult&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;     function mapOffset() {&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;         local -ri inputOffset=&quot;$1&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;         if (( &quot;$inputOffset&quot; &amp;lt;= 0 )); then&lt;/span&gt;
&lt;span class=&quot;org-diff-hunk-header&quot;&gt;@@ -410,7 +411,7 @@&lt;/span&gt;&lt;span class=&quot;org-diff-function&quot;&gt; findInputs() {&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;         else&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;             local -ri outputOffset=&quot;$inputOffset - 1 + $targetOffset&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;         fi&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-removed&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;org-diff-removed&quot;&gt;        echo &quot;$outputOffset&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;        mapOffsetResult=&quot;$outputOffset&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;     }&lt;/span&gt;

&lt;span class=&quot;org-diff-context&quot;&gt;     # Host offset relative to that of the package whose immediate&lt;/span&gt;
&lt;span class=&quot;org-diff-hunk-header&quot;&gt;@@ -422,8 +423,8 @@&lt;/span&gt;&lt;span class=&quot;org-diff-function&quot;&gt; findInputs() {&lt;/span&gt;

&lt;span class=&quot;org-diff-context&quot;&gt;         # Host offset relative to the package currently being&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;         # built---as absolute an offset as will be used.&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-removed&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;org-diff-removed&quot;&gt;        local -i hostOffsetNext&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-removed&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;org-diff-removed&quot;&gt;        hostOffsetNext=&quot;$(mapOffset relHostOffset)&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;        mapOffset relHostOffset&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;        local -i hostOffsetNext=&quot;$mapOffsetResult&quot;&lt;/span&gt;

&lt;span class=&quot;org-diff-context&quot;&gt;         # Ensure we're in bounds relative to the package currently&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;         # being built.&lt;/span&gt;
&lt;span class=&quot;org-diff-hunk-header&quot;&gt;@@ -441,8 +442,8 @@&lt;/span&gt;&lt;span class=&quot;org-diff-function&quot;&gt; findInputs() {&lt;/span&gt;

&lt;span class=&quot;org-diff-context&quot;&gt;             # Target offset relative to the package currently being&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;             # built.&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-removed&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;org-diff-removed&quot;&gt;            local -i targetOffsetNext&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-removed&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;org-diff-removed&quot;&gt;            targetOffsetNext=&quot;$(mapOffset relTargetOffset)&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;            mapOffset relTargetOffset&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;            local -i targetOffsetNext=&quot;$mapOffsetResult&quot;&lt;/span&gt;

&lt;span class=&quot;org-diff-context&quot;&gt;             # Once again, ensure we're in bounds relative to the&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;             # package currently being built.&lt;/span&gt;

&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Similarly, this change makes &lt;code&gt;mapOffset&lt;/code&gt; set to it’s result to
&lt;code&gt;mapOffsetResult&lt;/code&gt; instead of printing it to stdout, avoiding the
subshell. Less functional, but more performant!
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;
&lt;pre class=&quot;src src-diff&quot;&gt;&lt;span class=&quot;org-diff-context&quot;&gt;diff --git a/pkgs/stdenv/generic/setup.sh b/pkgs/stdenv/generic/setup.sh&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;index 7e7f8739845b..e25ea735a93c 100644&lt;/span&gt;
&lt;span class=&quot;org-diff-header&quot;&gt;--- &lt;/span&gt;&lt;span class=&quot;org-diff-header&quot;&gt;&lt;span class=&quot;org-diff-file-header&quot;&gt;a/pkgs/stdenv/generic/setup.sh&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;org-diff-header&quot;&gt;+++ &lt;/span&gt;&lt;span class=&quot;org-diff-header&quot;&gt;&lt;span class=&quot;org-diff-file-header&quot;&gt;b/pkgs/stdenv/generic/setup.sh&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;org-diff-hunk-header&quot;&gt;@@ -73,21 +73,18 @@&lt;/span&gt;&lt;span class=&quot;org-diff-function&quot;&gt; _callImplicitHook() {&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;     set -u&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;     local def=&quot;$1&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;     local hookName=&quot;$2&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-removed&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;org-diff-removed&quot;&gt;    case &quot;$(type -t &quot;$hookName&quot;)&quot; in&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-removed&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;org-diff-removed&quot;&gt;        (function|alias|builtin)&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-removed&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;org-diff-removed&quot;&gt;            set +u&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-removed&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;org-diff-removed&quot;&gt;            &quot;$hookName&quot;;;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-removed&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;org-diff-removed&quot;&gt;        (file)&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-removed&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;org-diff-removed&quot;&gt;            set +u&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-removed&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;org-diff-removed&quot;&gt;            source &quot;$hookName&quot;;;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-removed&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;org-diff-removed&quot;&gt;        (keyword) :;;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-removed&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;org-diff-removed&quot;&gt;        (*) if [ -z &quot;${!hookName:-}&quot; ]; then&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-removed&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;org-diff-removed&quot;&gt;                return &quot;$def&quot;;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-removed&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;org-diff-removed&quot;&gt;            else&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-removed&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;org-diff-removed&quot;&gt;                set +u&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-removed&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;org-diff-removed&quot;&gt;                eval &quot;${!hookName}&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-removed&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;org-diff-removed&quot;&gt;            fi;;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-removed&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;org-diff-removed&quot;&gt;    esac&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;    if declare -F &quot;$hookName&quot; &amp;gt; /dev/null; then&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;        set +u&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;        &quot;$hookName&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;    elif type -p &quot;$hookName&quot; &amp;gt; /dev/null; then&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;        set +u&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;        source &quot;$hookName&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;    elif [ -n &quot;${!hookName:-}&quot; ]; then&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;        set +u&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;        eval &quot;${!hookName}&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;    else&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;        return &quot;$def&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;    fi&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;     # `_eval` expects hook to need nounset disable and leave it&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;     # disabled anyways, so Ok to to delegate. The alternative of a&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;     # return trap is no good because it would affect nested returns.&lt;/span&gt;

&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
This change replaces the &lt;code&gt;type -t&lt;/code&gt; command with calls to specific Bash
builtins. &lt;code&gt;declare -F&lt;/code&gt; tells us if the hook is a function, &lt;code&gt;type -p&lt;/code&gt;
tells us if &lt;code&gt;hookName&lt;/code&gt; is a file, and otherwise &lt;code&gt;-n&lt;/code&gt; tells us if the
hook is non-empty. Again, this introduces a Bashism.
&lt;/p&gt;

&lt;p&gt;
In the worst case, this does replace one &lt;code&gt;case&lt;/code&gt; with multiple &lt;code&gt;if&lt;/code&gt;
branches. But since most hooks are functions, most of the time this
ends up being a single &lt;code&gt;if&lt;/code&gt;.
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;
&lt;pre class=&quot;src src-diff&quot;&gt;&lt;span class=&quot;org-diff-context&quot;&gt;diff --git a/pkgs/stdenv/generic/setup.sh b/pkgs/stdenv/generic/setup.sh&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;index e25ea735a93c..ea550a6d534b 100644&lt;/span&gt;
&lt;span class=&quot;org-diff-header&quot;&gt;--- &lt;/span&gt;&lt;span class=&quot;org-diff-header&quot;&gt;&lt;span class=&quot;org-diff-file-header&quot;&gt;a/pkgs/stdenv/generic/setup.sh&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;org-diff-header&quot;&gt;+++ &lt;/span&gt;&lt;span class=&quot;org-diff-header&quot;&gt;&lt;span class=&quot;org-diff-file-header&quot;&gt;b/pkgs/stdenv/generic/setup.sh&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;org-diff-hunk-header&quot;&gt;@@ -449,7 +449,8 @@&lt;/span&gt;&lt;span class=&quot;org-diff-function&quot;&gt; findInputs() {&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;             [[ -f &quot;$pkg/nix-support/$file&quot; ]] || continue&lt;/span&gt;

&lt;span class=&quot;org-diff-context&quot;&gt;             local pkgNext&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-removed&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;org-diff-removed&quot;&gt;            for pkgNext in $(&amp;lt; &quot;$pkg/nix-support/$file&quot;); do&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;            read -r -d '' pkgNext &amp;lt; &quot;$pkg/nix-support/$file&quot; || true&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;            for pkgNext in $pkgNext; do&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;                 findInputs &quot;$pkgNext&quot; &quot;$hostOffsetNext&quot; &quot;$targetOffsetNext&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;             done&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;         done&lt;/span&gt;

&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
This change replaces the &lt;code&gt;$(&amp;lt; )&lt;/code&gt; call with a &lt;code&gt;read&lt;/code&gt; call. This is a
little surprising since &lt;code&gt;read&lt;/code&gt; is using an empty delimiter &lt;code&gt;''&lt;/code&gt;
instead of a new line. This replaces one Bashsism &lt;code&gt;$(&amp;lt; )&lt;/code&gt; with another
in &lt;code&gt;-d&lt;/code&gt;. And, the result, gets rid of a remaining subshell usage.
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;
&lt;pre class=&quot;src src-diff&quot;&gt;&lt;span class=&quot;org-diff-context&quot;&gt;diff --git a/pkgs/build-support/bintools-wrapper/setup-hook.sh b/pkgs/build-support/bintools-wrapper/setup-hook.sh&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;index f65b792485a0..27d3e6ad5120 100644&lt;/span&gt;
&lt;span class=&quot;org-diff-header&quot;&gt;--- &lt;/span&gt;&lt;span class=&quot;org-diff-header&quot;&gt;&lt;span class=&quot;org-diff-file-header&quot;&gt;a/pkgs/build-support/bintools-wrapper/setup-hook.sh&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;org-diff-header&quot;&gt;+++ &lt;/span&gt;&lt;span class=&quot;org-diff-header&quot;&gt;&lt;span class=&quot;org-diff-file-header&quot;&gt;b/pkgs/build-support/bintools-wrapper/setup-hook.sh&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;org-diff-hunk-header&quot;&gt;@@ -61,9 +61,8 @@&lt;/span&gt;&lt;span class=&quot;org-diff-function&quot;&gt; do&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;     if&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;         PATH=$_PATH type -p &quot;@targetPrefix@${cmd}&quot; &amp;gt; /dev/null&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;     then&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-removed&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;org-diff-removed&quot;&gt;        upper_case=&quot;$(echo &quot;$cmd&quot; | tr &quot;[:lower:]&quot; &quot;[:upper:]&quot;)&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-removed&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;org-diff-removed&quot;&gt;        export &quot;${role_pre}${upper_case}=@targetPrefix@${cmd}&quot;;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-removed&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;org-diff-removed&quot;&gt;        export &quot;${upper_case}${role_post}=@targetPrefix@${cmd}&quot;;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;        export &quot;${role_pre}${cmd^^}=@targetPrefix@${cmd}&quot;;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;        export &quot;${cmd^^}${role_post}=@targetPrefix@${cmd}&quot;;&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;     fi&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt; done&lt;/span&gt;

&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
This replace a call to &lt;code&gt;tr&lt;/code&gt; with a usage of the &lt;code&gt;^^&lt;/code&gt;.
&lt;code&gt;${parameter^^pattern}&lt;/code&gt; is &lt;a href=&quot;https://www.gnu.org/software/bash/manual/bash.html#Shell-Parameter-Expansion&quot;&gt;a Bash 4 feature&lt;/a&gt; and allows you to
upper-case a string without calling out to &lt;code&gt;tr&lt;/code&gt;.
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;
&lt;pre class=&quot;src src-diff&quot;&gt;&lt;span class=&quot;org-diff-context&quot;&gt;diff --git a/pkgs/build-support/bintools-wrapper/setup-hook.sh b/pkgs/build-support/bintools-wrapper/setup-hook.sh&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;index 27d3e6ad5120..2e15fa95c794 100644&lt;/span&gt;
&lt;span class=&quot;org-diff-header&quot;&gt;--- &lt;/span&gt;&lt;span class=&quot;org-diff-header&quot;&gt;&lt;span class=&quot;org-diff-file-header&quot;&gt;a/pkgs/build-support/bintools-wrapper/setup-hook.sh&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;org-diff-header&quot;&gt;+++ &lt;/span&gt;&lt;span class=&quot;org-diff-header&quot;&gt;&lt;span class=&quot;org-diff-file-header&quot;&gt;b/pkgs/build-support/bintools-wrapper/setup-hook.sh&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;org-diff-hunk-header&quot;&gt;@@ -24,7 +24,8 @@&lt;/span&gt;&lt;span class=&quot;org-diff-function&quot;&gt; bintoolsWrapper_addLDVars () {&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;         # Python and Haskell packages often only have directories like $out/lib/ghc-8.4.3/ or&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;         # $out/lib/python3.6/, so having them in LDFLAGS just makes the linker search unnecessary&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;         # directories and bloats the size of the environment variable space.&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-removed&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;org-diff-removed&quot;&gt;        if [[ -n &quot;$(echo $1/lib/lib*)&quot; ]]; then&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;        local -a glob=( $1/lib/lib* )&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;        if [ &quot;${#glob[*]}&quot; -gt 0 ]; then&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;             export NIX_${role_pre}LDFLAGS+=&quot; -L$1/lib&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;         fi&lt;/span&gt;
     fi
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Here, we are checking for whether any files exist in &lt;code&gt;/lib/lib*&lt;/code&gt; using
a glob. It originally used a subshell to check if the result was
empty, but this change replaces it with the Bash &lt;code&gt;${#parameter}&lt;/code&gt;
&lt;a href=&quot;https://www.gnu.org/software/bash/manual/bash.html#Shell-Parameter-Expansion&quot;&gt;length operation&lt;/a&gt;.
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;
&lt;pre class=&quot;src src-diff&quot;&gt;&lt;span class=&quot;org-diff-context&quot;&gt;diff --git a/pkgs/stdenv/generic/setup.sh b/pkgs/stdenv/generic/setup.sh&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;index 311292169ecd..326a60676a26 100644&lt;/span&gt;
&lt;span class=&quot;org-diff-header&quot;&gt;--- &lt;/span&gt;&lt;span class=&quot;org-diff-header&quot;&gt;&lt;span class=&quot;org-diff-file-header&quot;&gt;a/pkgs/stdenv/generic/setup.sh&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;org-diff-header&quot;&gt;+++ &lt;/span&gt;&lt;span class=&quot;org-diff-header&quot;&gt;&lt;span class=&quot;org-diff-file-header&quot;&gt;b/pkgs/stdenv/generic/setup.sh&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;org-diff-hunk-header&quot;&gt;@@ -17,7 +17,8 @@&lt;/span&gt;&lt;span class=&quot;org-diff-function&quot;&gt; fi&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt; # code). The hooks for &amp;lt;hookName&amp;gt; are the shell function or variable&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt; # &amp;lt;hookName&amp;gt;, and the values of the shell array ‘&amp;lt;hookName&amp;gt;Hooks’.&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt; runHook() {&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-removed&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;org-diff-removed&quot;&gt;    local oldOpts=&quot;$(shopt -po nounset)&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;    local oldOpts=&quot;-u&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;    shopt -qo nounset || oldOpts=&quot;+u&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;     set -u # May be called from elsewhere, so do `set -u`.&lt;/span&gt;

&lt;span class=&quot;org-diff-context&quot;&gt;     local hookName=&quot;$1&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-hunk-header&quot;&gt;@@ -32,7 +33,7 @@&lt;/span&gt;&lt;span class=&quot;org-diff-function&quot;&gt; runHook() {&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;         set -u # To balance `_eval`&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;     done&lt;/span&gt;

&lt;span class=&quot;org-diff-indicator-removed&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;org-diff-removed&quot;&gt;    eval &quot;${oldOpts}&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;    set &quot;$oldOpts&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;     return 0&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt; }&lt;/span&gt;

&lt;span class=&quot;org-diff-hunk-header&quot;&gt;@@ -40,7 +41,8 @@&lt;/span&gt;&lt;span class=&quot;org-diff-function&quot;&gt; runHook() {&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt; # Run all hooks with the specified name, until one succeeds (returns a&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt; # zero exit code). If none succeed, return a non-zero exit code.&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt; runOneHook() {&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-removed&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;org-diff-removed&quot;&gt;    local oldOpts=&quot;$(shopt -po nounset)&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;    local oldOpts=&quot;-u&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;    shopt -qo nounset || oldOpts=&quot;+u&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;     set -u # May be called from elsewhere, so do `set -u`.&lt;/span&gt;

&lt;span class=&quot;org-diff-context&quot;&gt;     local hookName=&quot;$1&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-hunk-header&quot;&gt;@@ -57,7 +59,7 @@&lt;/span&gt;&lt;span class=&quot;org-diff-function&quot;&gt; runOneHook() {&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;         set -u # To balance `_eval`&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;     done&lt;/span&gt;

&lt;span class=&quot;org-diff-indicator-removed&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;org-diff-removed&quot;&gt;    eval &quot;${oldOpts}&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;    set &quot;$oldOpts&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;     return &quot;$ret&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt; }&lt;/span&gt;

&lt;span class=&quot;org-diff-hunk-header&quot;&gt;@@ -500,10 +502,11 @@&lt;/span&gt;&lt;span class=&quot;org-diff-function&quot;&gt; activatePackage() {&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;     (( &quot;$hostOffset&quot; &amp;lt;= &quot;$targetOffset&quot; )) || exit -1&lt;/span&gt;

&lt;span class=&quot;org-diff-context&quot;&gt;     if [ -f &quot;$pkg&quot; ]; then&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-removed&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;org-diff-removed&quot;&gt;        local oldOpts=&quot;$(shopt -po nounset)&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;        local oldOpts=&quot;-u&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;        shopt -qo nounset || oldOpts=&quot;+u&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;         set +u&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;         source &quot;$pkg&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-removed&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;org-diff-removed&quot;&gt;        eval &quot;$oldOpts&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;        set &quot;$oldOpts&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;     fi&lt;/span&gt;

&lt;span class=&quot;org-diff-context&quot;&gt;     # Only dependencies whose host platform is guaranteed to match the&lt;/span&gt;
&lt;span class=&quot;org-diff-hunk-header&quot;&gt;@@ -522,10 +525,11 @@&lt;/span&gt;&lt;span class=&quot;org-diff-function&quot;&gt; activatePackage() {&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;     fi&lt;/span&gt;

&lt;span class=&quot;org-diff-context&quot;&gt;     if [[ -f &quot;$pkg/nix-support/setup-hook&quot; ]]; then&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-removed&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;org-diff-removed&quot;&gt;        local oldOpts=&quot;$(shopt -po nounset)&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;        local oldOpts=&quot;-u&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;        shopt -qo nounset || oldOpts=&quot;+u&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;         set +u&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;         source &quot;$pkg/nix-support/setup-hook&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-removed&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;org-diff-removed&quot;&gt;        eval &quot;$oldOpts&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;        set &quot;$oldOpts&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;     fi&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt; }&lt;/span&gt;

&lt;span class=&quot;org-diff-hunk-header&quot;&gt;@@ -1273,17 +1277,19 @@&lt;/span&gt;&lt;span class=&quot;org-diff-function&quot;&gt; showPhaseHeader() {&lt;/span&gt;

&lt;span class=&quot;org-diff-context&quot;&gt; genericBuild() {&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;     if [ -f &quot;${buildCommandPath:-}&quot; ]; then&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-removed&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;org-diff-removed&quot;&gt;        local oldOpts=&quot;$(shopt -po nounset)&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;        local oldOpts=&quot;-u&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;        shopt -qo nounset || oldOpts=&quot;+u&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;         set +u&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;         source &quot;$buildCommandPath&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-removed&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;org-diff-removed&quot;&gt;        eval &quot;$oldOpts&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;        set &quot;$oldOpts&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;         return&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;     fi&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;     if [ -n &quot;${buildCommand:-}&quot; ]; then&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-removed&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;org-diff-removed&quot;&gt;        local oldOpts=&quot;$(shopt -po nounset)&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;        local oldOpts=&quot;-u&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;        shopt -qo nounset || oldOpts=&quot;+u&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;         set +u&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;         eval &quot;$buildCommand&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-removed&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;org-diff-removed&quot;&gt;        eval &quot;$oldOpts&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;        set &quot;$oldOpts&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;         return&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;     fi&lt;/span&gt;

&lt;span class=&quot;org-diff-hunk-header&quot;&gt;@@ -1313,10 +1319,11 @@&lt;/span&gt;&lt;span class=&quot;org-diff-function&quot;&gt; genericBuild() {&lt;/span&gt;

&lt;span class=&quot;org-diff-context&quot;&gt;         # Evaluate the variable named $curPhase if it exists, otherwise the&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;         # function named $curPhase.&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-removed&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;org-diff-removed&quot;&gt;        local oldOpts=&quot;$(shopt -po nounset)&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;        local oldOpts=&quot;-u&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;        shopt -qo nounset || oldOpts=&quot;+u&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;         set +u&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;         eval &quot;${!curPhase:-$curPhase}&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-removed&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;org-diff-removed&quot;&gt;        eval &quot;$oldOpts&quot;&lt;/span&gt;
&lt;span class=&quot;org-diff-indicator-added&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;org-diff-added&quot;&gt;        set &quot;$oldOpts&quot;&lt;/span&gt;

&lt;span class=&quot;org-diff-context&quot;&gt;         if [ &quot;$curPhase&quot; = unpackPhase ]; then&lt;/span&gt;
&lt;span class=&quot;org-diff-context&quot;&gt;             cd &quot;${sourceRoot:-.}&quot;&lt;/span&gt;

&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
This last change is maybe the trickiest. &lt;code&gt;$(shopt -po nounset)&lt;/code&gt; is
used to get &lt;a href=&quot;https://www.gnu.org/software/bash/manual/bash.html#The-Shopt-Builtin&quot;&gt;the old value&lt;/a&gt; of &lt;code&gt;nounset&lt;/code&gt;. The &lt;code&gt;nounset&lt;/code&gt; setting tells
Bash to treat &lt;a href=&quot;https://www.gnu.org/software/bash/manual/bash.html#The-Set-Builtin&quot;&gt;unset variables as an error&lt;/a&gt;. This is used temporarily
for phases and hooks to enforce this property. It will be reset to its
previous value after we finish evaling the current phase or hook. To
avoid the subshell here, the stdout provided in &lt;code&gt;shopt -po&lt;/code&gt; is
replaced with an exit code provided in &lt;code&gt;shopt -qo nounset&lt;/code&gt;. If the
&lt;code&gt;shopt -qo nounset&lt;/code&gt; fails, we set &lt;code&gt;oldOpts&lt;/code&gt; to &lt;code&gt;+u&lt;/code&gt;, otherwise it is
assumed that it is &lt;code&gt;-u&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
This commit was first merged in on September 20, but it takes a while
for it to hit master. Today, it was finally merged into master
(October 13) in &lt;a href=&quot;https://github.com/NixOS/nixpkgs/commits/4e6826a&quot;&gt;4e6826a&lt;/a&gt; so we can finally can see the benefits from
it!
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;outline-3&quot; id=&quot;outline-container-org2621377&quot;&gt;
&lt;h3 id=&quot;org2621377&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.2&lt;/span&gt; Benchmarking&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-2&quot;&gt;
&lt;p&gt;
Hyperfine makes it easy to compare differences in timings. You can
install it locally with:
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;
&lt;pre class=&quot;src src-shell&quot;&gt;$ nix-env -iA nixpkgs.hyperfine
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Here are some of the results:
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;
&lt;pre class=&quot;src src-shell&quot;&gt;$ hyperfine --warmup 3 &lt;span class=&quot;org-sh-escaped-newline&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;org-string&quot;&gt;'nix-shell -I nixpkgs=https://github.com/NixOS/nixpkgs/archive/33366cc.tar.gz -p stdenv --run :'&lt;/span&gt; &lt;span class=&quot;org-sh-escaped-newline&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;org-string&quot;&gt;'nix-shell -I nixpkgs=https://github.com/NixOS/nixpkgs/archive/4e6826a.tar.gz -p stdenv --run :'&lt;/span&gt;
Benchmark &lt;span class=&quot;org-comment-delimiter&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;org-comment&quot;&gt;1: nix-shell -I nixpkgs=https://github.com/NixOS/nixpkgs/archive/33366cc.tar.gz -p stdenv --run :&lt;/span&gt;
  Time (mean ± σ):     436.4 ms ±   8.5 ms    [User: 324.7 ms, System: 107.8 ms]
  Range (min … max):   430.8 ms … 459.6 ms    10 runs

Benchmark &lt;span class=&quot;org-comment-delimiter&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;org-comment&quot;&gt;2: nix-shell -I nixpkgs=https://github.com/NixOS/nixpkgs/archive/4e6826a.tar.gz -p stdenv --run :&lt;/span&gt;
  Time (mean ± σ):     244.5 ms ±   2.3 ms    [User: 190.7 ms, System: 34.2 ms]
  Range (min … max):   241.8 ms … 248.3 ms    12 runs

Summary
  &lt;span class=&quot;org-string&quot;&gt;'nix-shell -I nixpkgs=https://github.com/NixOS/nixpkgs/archive/4e6826a.tar.gz -p stdenv --run :'&lt;/span&gt; ran
&lt;span class=&quot;org-whitespace-line&quot;&gt;    1.79 ± 0.04 times faster than &lt;/span&gt;&lt;span class=&quot;org-string&quot;&gt;&lt;span class=&quot;org-whitespace-line&quot;&gt;'nix-shell -I nixpkgs=https://github.com/NixOS/nixpkgs/archive/33366cc.tar.gz -p stdenv --run :'&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;org-src-container&quot;&gt;
&lt;pre class=&quot;src src-shell&quot;&gt;$ hyperfine --warmup 3 &lt;span class=&quot;org-sh-escaped-newline&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;org-string&quot;&gt;'nix-shell -I nixpkgs=https://github.com/NixOS/nixpkgs/archive/33366cc.tar.gz -p i3.buildInputs --run :'&lt;/span&gt; &lt;span class=&quot;org-sh-escaped-newline&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;org-string&quot;&gt;'nix-shell -I nixpkgs=https://github.com/NixOS/nixpkgs/archive/4e6826a.tar.gz -p i3.buildInputs --run :'&lt;/span&gt;
Benchmark &lt;span class=&quot;org-comment-delimiter&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;org-comment&quot;&gt;1: nix-shell -I nixpkgs=https://github.com/NixOS/nixpkgs/archive/33366cc.tar.gz -p i3.buildInputs --run :&lt;/span&gt;
  Time (mean ± σ):      3.428 s ±  0.015 s    [User: 2.489 s, System: 1.081 s]
  Range (min … max):    3.404 s …  3.453 s    10 runs

Benchmark &lt;span class=&quot;org-comment-delimiter&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;org-comment&quot;&gt;2: nix-shell -I nixpkgs=https://github.com/NixOS/nixpkgs/archive/4e6826a.tar.gz -p i3.buildInputs --run :&lt;/span&gt;
  Time (mean ± σ):     873.4 ms ±  12.2 ms    [User: 714.7 ms, System: 89.3 ms]
  Range (min … max):   861.5 ms … 906.4 ms    10 runs

Summary
  &lt;span class=&quot;org-string&quot;&gt;'nix-shell -I nixpkgs=https://github.com/NixOS/nixpkgs/archive/4e6826a.tar.gz -p i3.buildInputs --run :'&lt;/span&gt; ran
&lt;span class=&quot;org-whitespace-line&quot;&gt;    3.92 ± 0.06 times faster than &lt;/span&gt;&lt;span class=&quot;org-string&quot;&gt;&lt;span class=&quot;org-whitespace-line&quot;&gt;'nix-shell -I nixpkgs=https://github.com/NixOS/nixpkgs/archive/33366cc.tar.gz -p i3.buildInputs --run :'&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;org-src-container&quot;&gt;
&lt;pre class=&quot;src src-shell&quot;&gt;$ hyperfine --warmup 3 &lt;span class=&quot;org-sh-escaped-newline&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;org-string&quot;&gt;'nix-shell -I nixpkgs=https://github.com/NixOS/nixpkgs/archive/33366cc.tar.gz -p inkscape.buildInputs --run :'&lt;/span&gt; &lt;span class=&quot;org-sh-escaped-newline&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;org-string&quot;&gt;'nix-shell -I nixpkgs=https://github.com/NixOS/nixpkgs/archive/4e6826a.tar.gz -p inkscape.buildInputs --run :'&lt;/span&gt;
&lt;span class=&quot;org-whitespace-line&quot;&gt;Benchmark &lt;/span&gt;&lt;span class=&quot;org-comment-delimiter&quot;&gt;&lt;span class=&quot;org-whitespace-line&quot;&gt;#&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;org-comment&quot;&gt;&lt;span class=&quot;org-whitespace-line&quot;&gt;1: nix-shell -I nixpkgs=https://github.com/NixOS/nixpkgs/archive/33366cc.tar.gz -p inkscape.buildInputs --run :&lt;/span&gt;&lt;/span&gt;
  Time (mean ± σ):      4.380 s ±  0.024 s    [User: 3.155 s, System: 1.443 s]
  Range (min … max):    4.339 s …  4.409 s    10 runs

&lt;span class=&quot;org-whitespace-line&quot;&gt;Benchmark &lt;/span&gt;&lt;span class=&quot;org-comment-delimiter&quot;&gt;&lt;span class=&quot;org-whitespace-line&quot;&gt;#&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;org-comment&quot;&gt;&lt;span class=&quot;org-whitespace-line&quot;&gt;2: nix-shell -I nixpkgs=https://github.com/NixOS/nixpkgs/archive/4e6826a.tar.gz -p inkscape.buildInputs --run :&lt;/span&gt;&lt;/span&gt;
  Time (mean ± σ):      1.007 s ±  0.011 s    [User: 826.7 ms, System: 114.2 ms]
  Range (min … max):    0.995 s …  1.026 s    10 runs

Summary
  &lt;span class=&quot;org-string&quot;&gt;'nix-shell -I nixpkgs=https://github.com/NixOS/nixpkgs/archive/4e6826a.tar.gz -p inkscape.buildInputs --run :'&lt;/span&gt; ran
&lt;span class=&quot;org-whitespace-line&quot;&gt;    4.35 ± 0.05 times faster than &lt;/span&gt;&lt;span class=&quot;org-string&quot;&gt;&lt;span class=&quot;org-whitespace-line&quot;&gt;'nix-shell -I nixpkgs=https://github.com/NixOS/nixpkgs/archive/33366cc.tar.gz -p inkscape.buildInputs --run :'&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Try running these commands yourself, and compare the results.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;outline-3&quot; id=&quot;outline-container-orgec0cdcf&quot;&gt;
&lt;h3 id=&quot;orgec0cdcf&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.3&lt;/span&gt; Results&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-3&quot;&gt;
&lt;p&gt;
Avoiding subshells leads to a decrease in up to 4x of the time it used
to take. That multiplier is going to depend on precisely how many
inputs we are processing. It’s a pretty impressive improvement, and it
comes with no added cost. These kind of easy wins in performance are
pretty rare, and worth celebrating!
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
	<pubDate>Sun, 13 Oct 2019 00:00:00 +0000</pubDate>
</item>
<item>
	<title>Hercules Labs: Agent 0.5.0 with Terraform support and simpler configuration</title>
	<guid isPermaLink="true">https://blog.hercules-ci.com/2019/10/07/agent-0.5.0-more-terraform-less-configuration/</guid>
	<link>https://blog.hercules-ci.com/2019/10/07/agent-0.5.0-more-terraform-less-configuration/</link>
	<description>&lt;p&gt;Last week, we’ve released &lt;a href=&quot;https://github.com/hercules-ci/hercules-ci-agent/releases/tag/hercules-ci-agent-0.5.0&quot;&gt;agent version 0.5.0&lt;/a&gt;. The main theme for the release is ease of installation. Running an agent should be as simple as possible, so we made:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;simplifications to the binary cache configuration&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/hercules-ci/terraform-hercules-ci#readme&quot;&gt;terraform modules and an example&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Follow &lt;a href=&quot;https://docs.hercules-ci.com/hercules-ci/getting-started/&quot;&gt;getting started guide&lt;/a&gt; to set up your first agent.&lt;/p&gt;

&lt;p&gt;If you have and you’re using the module (NixOS, NixOps, nix-darwin) the update is entirely self-explanatory. Otherwise, check &lt;a href=&quot;https://github.com/hercules-ci/hercules-ci-agent/releases/tag/hercules-ci-agent-0.5.0&quot;&gt;the notes&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;trusted-user&quot;&gt;Trusted-user&lt;/h3&gt;

&lt;p&gt;The agent now relies on being a &lt;code class=&quot;highlighter-rouge&quot;&gt;trusted-user&lt;/code&gt; to the Nix daemon. The agent does not allow projects to execute arbitrary Nix store operations anyway. It may improve security since it simplifies configuration and secrets handling.&lt;/p&gt;

&lt;p&gt;The security model for the agent is simple at this point: only build git refs from your repository. This way, third-party contributors can not run arbitrary code on your agent system; only contributors with write access to the repo can.&lt;/p&gt;

&lt;p&gt;Talking about trust, we’ll &lt;a href=&quot;https://github.com/hercules-ci/docs.hercules-ci.com/issues/67&quot;&gt;share some details&lt;/a&gt; about securely doing CI for Open Source with Bors soon!&lt;/p&gt;</description>
	<pubDate>Mon, 07 Oct 2019 00:00:00 +0000</pubDate>
</item>
<item>
	<title>Craige McWhirter: Installing LineageOS 16 on a Samsung SM-T710 (gts28wifi)</title>
	<guid isPermaLink="true">http://mcwhirter.com.au//craige/blog/2019/Installing_LineageOS_16_on_Samsung_T710/</guid>
	<link>http://mcwhirter.com.au//craige/blog/2019/Installing_LineageOS_16_on_Samsung_T710/</link>
	<description>&lt;ol&gt;
&lt;li&gt;Check the prerequisites&lt;/li&gt;
&lt;li&gt;Backup any files you want to keep&lt;/li&gt;
&lt;li&gt;Download LineageOS ROM and optional GAPPS package&lt;/li&gt;
&lt;li&gt;Copy LineageOS image &amp;amp; additional packages to the SM-T710&lt;/li&gt;
&lt;li&gt;Boot into recovery mode&lt;/li&gt;
&lt;li&gt;Wipe the existing installation.&lt;/li&gt;
&lt;li&gt;Format the device&lt;/li&gt;
&lt;li&gt;Install LineageOS ROM and other optional ROMs.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;strong&gt;0 - Check the Prerequisites&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The device already has the &lt;a href=&quot;https://source.mcwhirter.io/craige/hardware-notes/src/branch/master/samsung/SM-T710.rst&quot;&gt;latest TWRP
installed&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Android debugging is enabled on the device&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.android.com/studio/command-line/adb&quot;&gt;ADB&lt;/a&gt; is installed on
your workstation.&lt;/li&gt;
&lt;li&gt;You have a suitably configured SD card as a back up handy.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I use this &lt;a href=&quot;https://source.mcwhirter.io/craige/nixos-examples/src/branch/master/development/mobile/android.nix&quot;&gt;android.nix&lt;/a&gt;
to ensure my &lt;a href=&quot;https://nixos.org/&quot;&gt;NixOS&lt;/a&gt; environment has the prerequisites
install and configured for it's side of the process.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1 - Backup any Files You Want to Keep&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I like to use &lt;code&gt;adb&lt;/code&gt; to pull the files from the device. There are also other
methods available too.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ adb pull /sdcard/MyFolder ./Downloads/MyDevice/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Usage of &lt;code&gt;adb&lt;/code&gt; is documented at &lt;a href=&quot;https://developer.android.com/studio/command-line/adb&quot;&gt;Android Debug Bridge&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2 - Download LineageOS ROM and optional GAPPS package&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I downloaded
&lt;a href=&quot;https://doc-14-2s-docs.googleusercontent.com/docs/securesc/ha0ro937gcuc7l7deffksulhg5h7mbp1/95vm843q4kbkiarmoi4894gi5u1n00nc/1570060800000/00470383411279991671/*/1l5Jn6O-mb8OfmfQqXZqKz4UD3O2Qq5-e?e=download&quot;&gt;lineage-16.0-20191001-UNOFFICIAL-gts28wifi.zip&lt;/a&gt; from
&lt;a href=&quot;https://drive.google.com/drive/folders/16vvKfv_wJa7eNizak8Wklm0ow38B5gLu&quot;&gt;gts28wifi&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I also downloaded &lt;a href=&quot;https://opengapps.org/&quot;&gt;Open GApps&lt;/a&gt; ARM, nano to enable
Google Apps.&lt;/p&gt;

&lt;p&gt;I could have also downloaded and installed LineageOS
&lt;a&gt;addonsu&lt;/a&gt; and
&lt;a&gt;addonsu-remove&lt;/a&gt;
but opted not to at this point.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3 - Copy LineageOS image &amp;amp; additional packages to the SM-T710&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I use &lt;code&gt;adb&lt;/code&gt; to copy the files files across:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ adb push ./lineage-16.0-20191001-UNOFFICIAL-gts28wifi.zip /sdcard/
./lineage-16.0-20191001-UNOFFICIAL-gts28wifi.zip: 1 file pushed. 12.1 MB/s (408677035 bytes in 32.263s)
$ adb push ./open_gapps-arm-9.0-nano-20190405.zip /sdcard/
./open_gapps-arm-9.0-nano-20190405.zip: 1 file pushed. 11.1 MB/s (185790181 bytes in 15.948s)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I also copy both to the SD card at this point as the SM-T710 is an awful device
to work with and in many random cases will not work with ADB. When this
happens, I fall back to the SD card.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4 - Boot into recovery mode&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I power the device off, then power it back into recovery mode by holding down
&lt;code&gt;[home]&lt;/code&gt;+&lt;code&gt;[volume up]&lt;/code&gt;+&lt;code&gt;[power]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5 - Wipe the existing installation&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Press &lt;strong&gt;Wipe&lt;/strong&gt; then &lt;strong&gt;Advanced Wipe&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Select:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Dalvik / Art Cache&lt;/li&gt;
&lt;li&gt;System&lt;/li&gt;
&lt;li&gt;Data&lt;/li&gt;
&lt;li&gt;Cache&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Swipe &lt;strong&gt;Swipe to Wipe&lt;/strong&gt; at the bottom of the screen.&lt;/p&gt;

&lt;p&gt;Press &lt;strong&gt;Back&lt;/strong&gt; to return to the &lt;strong&gt;Advanced Wipe&lt;/strong&gt; screen.&lt;/p&gt;

&lt;p&gt;Press the triangular &quot;back&quot; button once to return to the &lt;strong&gt;Wipe&lt;/strong&gt; screen.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6 - Format the device&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Press &lt;strong&gt;Format Data&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Type &lt;strong&gt;yes&lt;/strong&gt; and press blue check mark at the bottom-right corner to commence
the format process.&lt;/p&gt;

&lt;p&gt;Press &lt;strong&gt;Back&lt;/strong&gt; to return to the &lt;strong&gt;Advanced Wipe&lt;/strong&gt; screen.&lt;/p&gt;

&lt;p&gt;Press the triangular &quot;back&quot; button twice to return to the main screen.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7 - Install LineageOS ROM and other optional ROMs&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Press &lt;strong&gt;Install&lt;/strong&gt;, select the images you wish to install and swipe make it go.&lt;/p&gt;

&lt;p&gt;Reboot when it's completed and you should be off and running wtth a brand new
LineageOS 16 on this tablet.&lt;/p&gt;</description>
	<pubDate>Thu, 03 Oct 2019 23:04:41 +0000</pubDate>
</item>
<item>
	<title>Hercules Labs: Post-mortem on recent Cachix downtime</title>
	<guid isPermaLink="true">https://blog.hercules-ci.com/2019/09/30/recent-cachix-downtime/</guid>
	<link>https://blog.hercules-ci.com/2019/09/30/recent-cachix-downtime/</link>
	<description>&lt;p&gt;On 6th of September, &lt;a href=&quot;https://cachix.org&quot;&gt;Cachix&lt;/a&gt; experienced 3 hours of downtime.&lt;/p&gt;

&lt;p&gt;We’d like to let you know exactly what happened and what measures we have taken to prevent such an event from happening in the future.&lt;/p&gt;

&lt;h2 id=&quot;timeline-utc&quot;&gt;Timeline (UTC)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;2019-09-06 17:15:05: cachix.org down alert triggered&lt;/li&gt;
  &lt;li&gt;2019-09-06 20:06:00: Domen gets out of &lt;a href=&quot;https://munihac.de/2019.html&quot;&gt;MuniHac&lt;/a&gt; dinner in the basement and receives the alert&lt;/li&gt;
  &lt;li&gt;2019-09-06 20:19:00: Domen restarts server process&lt;/li&gt;
  &lt;li&gt;2019-09-06 20:19:38: cachix.org is back up&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;observations&quot;&gt;Observations&lt;/h2&gt;

&lt;p&gt;The backend logs were full of:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-log&quot;&gt;Sep 06 17:02:34 cachix-production.cachix cachix-server[6488]: Network.Socket.recvBuf: resource vanished (Connection reset by peer)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-log&quot;&gt;(ConnectionFailure Network.BSD.getProtocolByName: does not exist (no such protocol name: tcp)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Most importantly, there were no logs after downtime was triggered and until the restart:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-log&quot;&gt;Sep 06 17:15:48 cachix-production.cachix cachix-server[6488]: Network.Socket.recvBuf: resource vanished (Connection reset by peer)
Sep 06 20:19:26 cachix-production.cachix systemd[1]: Stopping cachix server service...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our monitoring revealed an increased number of nginx connections and file handles (the time are in CEST - UTC+2):&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;File handles and nginx connections&quot; src=&quot;https://blog.hercules-ci.com/images/cachix-downtime-monitoring.png&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;The main cause for downtime was hanged backend. The underlying cause was not identified
due to lack of information.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The backend was failing some requests due to reaching the limit of 1024 file descriptors.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The duration of the downtime was due to the absence of a telephone signal.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;what-weve-already-done&quot;&gt;What we’ve already done&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;To avoid any hangs in the future, we have configured &lt;a href=&quot;http://0pointer.de/blog/projects/watchdog.html&quot;&gt;systemd watchdog&lt;/a&gt;
which automatically restarts the service if the backend doesn’t respond for 3 seconds.
Doing so we released &lt;a href=&quot;https://github.com/hercules-ci/warp-systemd&quot;&gt;warp-systemd&lt;/a&gt; Haskell library to integrate Warp (Haskell web server)
with systemd, such as socket activation and watchdog features.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We’ve increased file descriptors limit to 8192.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We’ve set up &lt;a href=&quot;https://status.cachix.org/&quot;&gt;Cachix status page&lt;/a&gt; so that you can check the state of the service.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;For a better visibility into errors like file handles, we’ve configured &lt;a href=&quot;https://sentry.io&quot;&gt;sentry.io&lt;/a&gt;
error reporting.
Doing so we released &lt;a href=&quot;https://github.com/hercules-ci/katip-raven&quot;&gt;katip-raven&lt;/a&gt; for seamless Sentry integration
of structured logging which we also use to log Warp (Haskell web server) exceptions.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Robert is now fully onboarded to be able to resolve any Cachix issues&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We’ve made a number of improvements for the performance of Cachix. Just tuning GHC RTS settings
shows 15% speed up in common usage.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;future-work&quot;&gt;Future work&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Enable debugging builds for production. This would allow systemd watchdog to &lt;a href=&quot;https://mpickering.github.io/ghc-docs/build-html/users_guide/debug-info.html#requesting-a-stack-trace-with-sigquit&quot;&gt;send signal SIGQUIT&lt;/a&gt; and get an execution stack in which program hanged.&lt;/p&gt;

    &lt;p&gt;We opened &lt;a href=&quot;https://github.com/NixOS/nixpkgs/pull/69552&quot;&gt;nixpkgs pull request&lt;/a&gt; to lay the ground work
to be able to compile debugging builds.&lt;/p&gt;

    &lt;p&gt;However there’s a GHC bug opened showing &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/15960&quot;&gt;debugging builds alter the performance of programs&lt;/a&gt;, so we need to asses our impact first.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Upgrade &lt;a href=&quot;https://github.com/haskell/network&quot;&gt;network&lt;/a&gt; library to 3.0 fixing &lt;a href=&quot;https://github.com/snoyberg/http-client/issues/374#issuecomment-535919090&quot;&gt;unneeded file handle usage&lt;/a&gt; and &lt;a href=&quot;https://github.com/haskell/network-bsd/commit/2167eca412fa488f7b2622fcd61af1238153dae7&quot;&gt;a possible candidate for a deadlock&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://www.stackage.org/nightly-2019-09-30&quot;&gt;Stackage just included network-3.* in latest snapshot&lt;/a&gt;
so it’s a matter of weeks.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Improve load testing tooling to be able to reason about performance implications.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;We’re confident such issues shouldn’t affect the production anymore and since availability of
Cachix is our utmost priority, we are going to make sure to complete the rest of the work in a timely manner.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;what-we-do&quot;&gt;What we do&lt;/h2&gt;

&lt;p&gt;Automated hosted infrastructure for Nix, reliable and reproducible developer tooling,
to speed up adoption and lower integration cost. We offer
&lt;a href=&quot;https://hercules-ci.com&quot;&gt;Continuous Integration&lt;/a&gt; and &lt;a href=&quot;https://cachix.org&quot;&gt;Binary Caches&lt;/a&gt;.&lt;/p&gt;</description>
	<pubDate>Mon, 30 Sep 2019 00:00:00 +0000</pubDate>
</item>
<item>
	<title>Craige McWhirter: Setting Up Wireless Networking with NixOS</title>
	<guid isPermaLink="true">http://mcwhirter.com.au//craige/blog/2019/Setting_Up_Wireless_Networking_with_NixOS/</guid>
	<link>http://mcwhirter.com.au//craige/blog/2019/Setting_Up_Wireless_Networking_with_NixOS/</link>
	<description>&lt;p&gt;&lt;img alt=&quot;NixOS Gears by Craige McWhirter&quot; src=&quot;http://mcwhirter.com.au/files/NixOS_Gears.png&quot; title=&quot;NixOS Gears by Craige McWhirter&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The current &lt;a href=&quot;https://nixos.org/nixos/manual/&quot;&gt;NixOS Manual&lt;/a&gt; is a little sparse
on details for different options to &lt;a href=&quot;https://nixos.org/nixos/manual/index.html#sec-wireless&quot;&gt;configure wireless
networking&lt;/a&gt;. The
&lt;a href=&quot;https://github.com/NixOS/nixpkgs/blob/master/nixos/doc/manual/configuration/wireless.xml&quot;&gt;version in
master&lt;/a&gt;
is a little better but still ambiguous. I've &lt;a href=&quot;https://github.com/NixOS/nixpkgs/pull/66652/files&quot;&gt;made a pull
request&lt;/a&gt; to resolve
this but in the interim, this documents how to configure a number of wireless
scenarios with NixOS.&lt;/p&gt;

&lt;p&gt;If you're going to use NetworkManager, this is not for you. This is for those
of us who want reproducible configurations.&lt;/p&gt;

&lt;p&gt;To enable a wireless connection with no spaces or special characters in the
name that uses a pre-shared key, you first need to generate the raw PSK:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ wpa_passphrase exampleSSID abcd1234
network={
        ssid=&quot;exampleSSID&quot;
        #psk=&quot;abcd1234&quot;
        psk=46c25aa68ccb90945621c1f1adbe93683f884f5f31c6e2d524eb6b446642762d
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you can add the following stanza to your configuration.nix to enable
wireless networking and this specific wireless connection:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;networking.wireless = {
  enable = true;
  userControlled.enable = true;
  networks = {
    exampleSSID = {
      pskRaw = &quot;46c25aa68ccb90945621c1f1adbe93683f884f5f31c6e2d524eb6b446642762d&quot;;
    };
  };
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you had another WiFi connection that had spaces and/or special characters in the name, you would configure it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;networking.wireless = {
  enable = true;
  userControlled.enable = true;
  networks = {
    &quot;example's SSID&quot; = {
      pskRaw = &quot;46c25aa68ccb90945621c1f1adbe93683f884f5f31c6e2d524eb6b446642762d&quot;;
    };
  };
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you need to connect to a hidden network, you would do it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;networking.wireless = {
  enable = true;
  userControlled.enable = true;
  networks = {
    myHiddenSSID = {
      hidden = true;
      pskRaw = &quot;46c25aa68ccb90945621c1f1adbe93683f884f5f31c6e2d524eb6b446642762d&quot;;
    };
  };
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final scenario that I have, is connecting to open SSIDs that have some kind
of secondary method (like a login in web page) for authentication of
connections:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;networking.wireless = {
  enable = true;
  userControlled.enable = true;
  networks = {
    FreeWiFi = {};
  };
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is all fairly straight forward but was non-trivial to find the answers
too.&lt;/p&gt;</description>
	<pubDate>Thu, 26 Sep 2019 21:38:34 +0000</pubDate>
</item>

</channel>
</rss>
